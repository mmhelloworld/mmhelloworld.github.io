<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Idris 2 | mmhelloworld]]></title>
  <link href="http://mmhelloworld.github.io/blog/categories/idris-2/atom.xml" rel="self"/>
  <link href="http://mmhelloworld.github.io/"/>
  <updated>2020-12-30T19:03:32-05:00</updated>
  <id>http://mmhelloworld.github.io/</id>
  <author>
    <name><![CDATA[Marimuthu Madasamy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Idris 2 Bootstrap Compiler on the JVM With a JVM Backend]]></title>
    <link href="http://mmhelloworld.github.io/blog/2020/12/30/idris-2-bootstrap-compiler-on-the-jvm-with-a-jvm-backend/"/>
    <updated>2020-12-30T13:34:21-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2020/12/30/idris-2-bootstrap-compiler-on-the-jvm-with-a-jvm-backend</id>
    <content type="html"><![CDATA[<p>I am excited to announce that Idris 2 bootstrap compiler can now run on the JVM along with a JVM backend. Here is a REPL session:</p>

<pre><code class="haskell">$ idris2
     ____    __     _         ___                                           
    /  _/___/ /____(_)____   |__ \                                          
    / // __  / ___/ / ___/   __/ /     Version 0.1.1-786152de1
  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org           
 /___/\__,_/_/  /_/____/   /____/      Type :? for help                     

[BOOTSTRAP VERSION: No longer developed, except as a bootstrapping step.]
Welcome to Idris 2 on the JVM (Private Build OpenJDK 64-Bit Server VM, 1.8.0_275).  Enjoy yourself!
Main&gt; "hello world"
"hello world"
Main&gt; take 10 [25..]
[25, 26, 27, 28, 29, 30, 31, 32, 33, 34]
Main&gt; :t map
Prelude.map : Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
Main&gt; :exec printLn "Hello Idris 2 on the JVM - this is printed from executing JVM bytecode from memory"
"Hello Idris 2 on the JVM - this is printed from executing JVM bytecode from memory"
Main&gt; 
</code></pre>

<p>You may notice that the banner includes the JVM version the Idris compiler is running on. Idris 2 for JVM can run on Java 8 or above. Since the compiler itself runs on the JVM, the last <code>:exec</code> command above can directly interpret the generated bytecode on the compiler JVM, and the generated bytecode is loaded from memory without any file system footprint.</p>

<h3>To try it out</h3>

<p>Prerequisite: Java 8 or above</p>

<ul>
<li>Extract the zip from <a href="https://github.com/mmhelloworld/Idris2-boot/releases/tag/v0.2.0">here</a></li>
<li>Add <code>idris2-boot-jvm/bin</code> from extracted directory to <code>PATH</code></li>
<li>Run <code>idris2</code>. That&rsquo;s all!</li>
</ul>


<h3>Features</h3>

<ul>
<li>Eliminate tail recursion using JVM&rsquo;s GOTO</li>
<li>Trampoline non-self tail calls</li>
<li>Support file, directory, array, IORef and buffer primitives.</li>
<li>Analyse function dependencies to generate bytecode for only used functions from <code>main</code></li>
<li>Limited type inference on Idris IR to avoid boxing and typecasting in the generated bytecode</li>
<li>Static and instance Java FFI method calls.</li>
<li>Debug information (Idris source file and line numbers) in the bytecode from Idris IR</li>
</ul>


<p>Currently the goal for this bootstrap compiler is to be able to compile current <a href="https://github.com/idris-lang/Idris2">Idris 2</a> so the items here could definitely be improved a lot and other features may be added to support the absolute minimum for building Idris 2.</p>

<h3>Example</h3>

<pre><code class="haskell">module Main

import System.FFI

-- Tail call is eliminated with GOTO
sum : Int -&gt; Int
sum n = go 0 n where
  go : Int -&gt; Int -&gt; Int
  go acc 0 = acc
  go acc n = go (acc + n) (n - 1)

mutual
  -- Mutually recursive functions are trampolined
  -- keeping it simple with int instead of Nat which is compiled to Java BigInteger
  isOdd : Int -&gt; Bool
  isOdd 0 = False
  isOdd n = isEven (n - 1)

  isEven : Int -&gt; Bool
  isEven 0 = True
  isEven n = isOdd (n - 1)

-- Java instance method calls
%foreign jvm "java/lang/String" ".length"
jvmStringLength : String -&gt; Int

-- Java static method calls
%foreign jvm "java/lang/Integer" "toBinaryString"
intToBinaryString : Int -&gt; String

main : IO ()
main = do
  printLn $ sum 5000
  printLn $ isEven 100000
  printLn $ intToBinaryString 512
  printLn $ jvmStringLength "hello"
</code></pre>

<h4>Compile</h4>

<pre><code>idris2 Main.idr -o main
</code></pre>

<p>The classes will be compiled into <code>build/exec/main_app</code>.
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>$ tree build/exec/main_app/
</span><span class='line'>build/exec/main_app/
</span><span class='line'>├── Main.class
</span><span class='line'>├── Prelude
</span><span class='line'>│   ├── $col$col.class
</span><span class='line'>│   ├── Just.class
</span><span class='line'>│   ├── Nil.class
</span><span class='line'>│   ├── Nothing.class
</span><span class='line'>│   ├── Open.class
</span><span class='line'>│   ├── PrefixMinus.class
</span><span class='line'>│   └── Show$spcat$spcPrelude$dotidr$col1260$col1&amp;ndash;1284$col1__mkShow.class
</span><span class='line'>├── Prelude.class
</span><span class='line'>└── PrimIO.class&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;It compiles down to three main modules `Main`, `Prelude` and `PrimIO`. Rest of the classes are data classes for Idris constructors like `Just`, `Nothing`, Nil`, `::` etc.
</span><span class='line'>
</span><span class='line'>#### Run
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ java -cp /path/to/idris2-boot-jvm/lib/runtime-1.0-SNAPSHOT.jar:build/exec/main_app Main
</span><span class='line'>12502500
</span><span class='line'>True
</span><span class='line'>&amp;ldquo;1000000000&amp;rdquo;
</span><span class='line'>5
</span></code></pre></td></tr></table></div></figure>
The above example demonstrates tail recursion, mutual recursion, Java FFI instance and static method calls.</p>

<p><code>sum</code> a tail recursive function, would be compiled into a loop.  Here is the decompiled code for the nested <code>go</code> function inside <code>sum</code>:</p>

<pre><code class="java">    public static Object $nested1201$307$go(Object arg$0, int arg$1, int arg$2) {
        while(true) {
            switch(arg$2) {
            case 0:
                return arg$1;
            default:
                arg$1 = Prelude.++_Num__Int(arg$1, arg$2);
                arg$2 = Prelude.--_Neg__Int(arg$2, 1);
            }
        }
    }
</code></pre>

<p>For <code>isEven</code> and <code>isOdd</code>, the tail calls would be trampolined using JVM&rsquo;s <code>invokedynamic</code>. Here is the decompiled bytecode.</p>

<pre><code class="java">    public static Object isOdd(int arg$0) {
        switch(arg$0) {
        case 0:
            return 1;
        default:
            return () -&gt; {
                return Runtime.createThunk(isEven(Prelude.--_Neg__Int(arg$0, 1)));
            };
        }
    }

    public static Object isEven(int arg$0) {
        switch(arg$0) {
        case 0:
            return 0;
        default:
            return () -&gt; {
                return Runtime.createThunk(isOdd(Prelude.--_Neg__Int(arg$0, 1)));
            };
        }
    }
</code></pre>

<p><code>jvmStringLength</code> function is an example for Java FFI instance method call. It calls <code>length</code> function on Java&rsquo;s <code>java.lang.String</code> instance. Similarly <code>intToBinaryString</code> calls <code>toBinaryString</code> static function on class <code>java.lang.Integer</code>. Function name starting with a dot denotes an instance method call differentiating it from a static method call. Precise types can also be passed explicitly as in the example below with argument types and return type (full code <a href="https://github.com/mmhelloworld/Idris2-boot/blob/master/libs/base/System/File.idr#L37">here</a>).</p>

<pre><code class="haskell">%foreign jvm' fileClass "getLine" fileClass "String"
prim__readLine : FilePtr -&gt; PrimIO (Ptr String)
</code></pre>

<h3>Next steps</h3>

<p>Next step would be to use this bootstrap version to compile current <a href="https://github.com/idris-lang/Idris2">Idris 2</a> and then porting the JVM backend from here which is on Idris 1 to Idris 2 so there are some interesting things ahead to work on. Meanwhile, if anyone gets a chance to use this boostrap JVM version, please share any feedback or any issues <a href="https://github.com/mmhelloworld/idris-jvm/discussions">here</a> that can help while we try to compile mainstream Idris 2 for the JVM. Thank you for reading and happy coding!</p>
]]></content>
  </entry>
  
</feed>
