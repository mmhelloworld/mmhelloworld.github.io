<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | mmhelloworld]]></title>
  <link href="http://mmhelloworld.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://mmhelloworld.github.io/"/>
  <updated>2020-12-30T21:13:52-05:00</updated>
  <id>http://mmhelloworld.github.io/</id>
  <author>
    <name><![CDATA[Marimuthu Madasamy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Idris JVM: Automated FFI With Null Safety and Exception Handling]]></title>
    <link href="http://mmhelloworld.github.io/blog/2018/02/11/idris-jvm-automated-ffi-with-null-safety/"/>
    <updated>2018-02-11T00:03:00-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2018/02/11/idris-jvm-automated-ffi-with-null-safety</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>Idris JVM backend has supported foreign function calls for some time now. For example, to invoke <code>parseInt</code> method on
<code>java.lang.Integer</code> class,</p>

<pre><code class="haskell">invokeStatic (Class "java/lang/Integer") "parseInt" (String -&gt; JVM_IO Int) "234" 
</code></pre>

<p>Here since the Idris compiler doesn&rsquo;t know anything about Java&rsquo;s <code>Integer</code> class or its <code>parseInt</code> method, we have to
explicitly provide the function signature. The function call also has the explicit <code>Class</code>
before <code>java/lang/Integer</code> and the type of invocation <code>invokeStatic</code>.</p>

<p>Since we are targeting JVM bytecode, JVM has to know whether a method call is a static method call or an interface
method call or a virtual method call. It would be nice if we don&rsquo;t have to worry about any of these things and
just call a FFI function with a class name, method name and the arguments. This is the motivation behind this
new feature along with some other nice things like null safety, construtor and method overloading resolution
and exception handling.</p>

<h4>Maybe and Either in foreign function calls</h4>

<p><code>Maybe</code> type and <code>Either</code> type can be used in foreign function calls for null safety and exception handling. <code>Maybe</code>
type can be used for argument types and return types. <code>Maybe</code> type used in an argument position will pass <code>null</code>
to the target foreign function if it is <code>Nothing</code> or the actual value if it is <code>Just</code>. Similarly, <code>Maybe</code> type
used for return type will convert <code>null</code> returned from foreign function into <code>Nothing</code> and the non-null value into
<code>Just.</code> At the bytecode level, <code>Maybe</code> wrapper doesn&rsquo;t exist. It gets compiled down to
<code>null</code> or the actual value.</p>

<p><code>Either</code> type can only be used in return types to indicate whether the foreign function can throw exceptions.
At runtime, if the foreign function throws exception, it will be captured in the &ldquo;left&rdquo; of type <code>Throwable</code> or if the
foreign function completes normally, the result will be stored in the &ldquo;right&rdquo; of result type. There are functions <code>try</code>
and <code>catch</code> to handle exceptions which we will see later in the post.</p>

<h2>How it works</h2>

<p>Before we look at some examples, first let&rsquo;s declare some class names as we are going to use them in multiple places and
we don&rsquo;t want to duplicate.</p>

<pre><code class="haskell">stringClass: String
stringClass = "java/lang/String"

listInterface: String
listInterface = "java/util/List"

arrayListClass: String
arrayListClass = "java/util/ArrayList"

collectionInterface : String
collectionInterface = "java/util/Collection"

systemClass: String
systemClass = "java/lang/System"

comparatorClass : String
comparatorClass = "java/util/Comparator"

pointClass : String
pointClass = "java/awt/Point"

collectionsClass : String
collectionsClass = "java/util/Collections"

stringBuilderClass : String
stringBuilderClass = "java/lang/StringBuilder"

objectsClass : String
objectsClass = "java/util/Objects"

integerClass : String
integerClass = "java/lang/Integer"
</code></pre>

<p>And &ldquo;import&rdquo; some methods:</p>

<pre><code class="haskell">jdkimport [
    (systemClass, ["getProperty", "setProperty"]),
    (stringClass, ["substring", "CASE_INSENSITIVE_ORDER", "valueOf"]),
    (integerClass, ["parseInt"]),
    (comparatorClass, ["compare"]),
    (arrayListClass, ["&lt;init&gt;", "add"]),
    (listInterface, ["get"]),
    (collectionsClass, ["max"]),
    (stringBuilderClass, ["&lt;init&gt;", "toString"]),
    (objectsClass, ["toString"]),
    (pointClass, ["&lt;init&gt;", "x"])
  ]
</code></pre>

<p>Here <code>jdkimport</code> is just an additional syntax created using Idris syntax extensions. It just calls a type provider
function written in Idris to know about these classes, methods and fields. Note that it imports fields such as
<code>CASE_INSENSITIVE_ORDER</code>, <code>x</code> and also constructors in the name of <code>&lt;init&gt;</code> which is the JVM internal name for
constructors. The <code>jdkimport</code> syntax launches a JVM during compilation without any classpath so it basically can import
all the JDK classes and methods.</p>

<p>There is also another syntax called <code>jvmimport</code> that can take an additional argument, a command, which could be just the
JVM with correct classpath or could be a build tool that properly sets up the classpath from your project dependencies so
that we can &ldquo;import&rdquo; classes and methods from external foreign libraries.</p>

<p>Once the information about JVM classes and methods is collected using type provider, appropriate call site, Idris code
similar to the one in the beginning of the post can be created using Idris elaborator reflection with just class name
and member name from the user. As a user, we don&rsquo;t have to know much about these internals, we just need to import classes
and members and can use them without having to explicitly provide foreign types. Now let&rsquo;s look at some examples on how we can
actually make FFI calls in the new way.</p>

<h2>Examples</h2>

<h4>1. Safe static method call</h4>

<pre><code class="haskell">main : JVM_IO ()
main = do
  exceptionOrInt &lt;- (integerClass &lt;.&gt; "parseInt") "1234"
  printLn $ either (const 0) id exceptionOrInt 
</code></pre>

<p>Here the type of <code>(integerClass &lt;.&gt; "parseInt")</code> is <code>String -&gt; JVM_IO (Either Throwable Int)</code>. Since the method can throw
exceptions, it returns an <code>Either</code>. Here we return <code>0</code> in case of an exception. Later in the post, we will see a
detailed example of exception handling. As the method returns an <code>Int</code> which is a primitive type in JVM, it cannot be
null and the FFI call already knows that hence the result <code>Int</code> is not wrapped in a <code>Maybe</code>. We don&rsquo;t provide any
explicit type signature for the foreign function. If we try to pass anything other than <code>String</code> for this foreign
function, it will be a compilation error!</p>

<h4>2. Unsafe static method call</h4>

<pre><code class="haskell">  do
    number &lt;- (integerClass &lt;.!&gt; "parseInt") "23"
    printLn number
</code></pre>

<p>Here we use <code>&lt;.!&gt;</code> with an <code>!</code> to indicate an unsafe method call instead of <code>&lt;.&gt;</code>. There is also <code>javaUnsafe</code> and <code>java</code>
if you prefer names to operators. The type of <code>(integerClass &lt;.!&gt; "parseInt")</code> is <code>String -&gt; JVM_IO Int</code>.
Sometimes if we are sure that the foreign function would not return null or throw exceptions, we can use unsafe method
calls but as the name indicates, it would fail at runtime if null is returned or an exception is thrown.</p>

<h4>3. Overloading resolution</h4>

<p>We can pick which overloaded variant we want to use by passing appropriate types to the foreign function and
the FFI call will automatically have corresponding types.</p>

<pre><code class="haskell">printLn !((stringClass &lt;.!&gt; "valueOf(double)") 2.5)
printLn !((stringClass &lt;.!&gt; "valueOf(char)") 'H')
</code></pre>

<p>The first function takes an Idris <code>Double</code> and the second function takes Idris <code>Char</code>. The types passed to the foreign
functions to resolve overloading are JVM types.</p>

<h4>4. Safe instance method</h4>

<pre><code class="haskell">  do
    s &lt;- (stringClass &lt;.&gt; "substring(int)") "Foobar" 1
    putStrLn !(either throw (pure . show) s) 
</code></pre>

<p>Safe instance method calls are similar to static method calls except that the instance should be passed as the first
argument. Here again, we don&rsquo;t provide any explicit type signature or the type of method invocation whether it is static or
instance method but it all works out automatically in a type safe way. Here also we pick a particular overloaded version.</p>

<p>The type of <code>(stringClass &lt;.&gt; "substring(int)")</code> is <code>String -&gt; Int -&gt; JVM_IO (Either Throwable (Maybe String))</code>.
Since the return type is <code>String</code> and it can be null, it is in a <code>Maybe</code> and the method can throw exceptions so the
overall type is in <code>Either</code>.</p>

<h4>5. Exception handling</h4>

<pre><code class="haskell">do
  propValue &lt;- try ((systemClass &lt;.&gt; "getProperty(?java/lang/String)") Nothing) [
    ([catch IllegalArgumentExceptionClass, catch NullPointerExceptionClass], \t =&gt;
      do
        printLn "property name is null or empty"
        pure Nothing
    ),
    ([catchNonFatal], \t =&gt;
      do
        printLn "unable to get property value"
        pure Nothing
    )
  ]
  printLn propValue
</code></pre>

<p>This example shows how to handle exceptions with different handlers and also shows how to pass a <code>null</code> to a foreign function.
If a FFI function argument type is prefixed with <code>?</code>, then the idris type would be <code>Maybe nativeTy</code> and we can pass
<code>Nothing</code> to pass a <code>null</code> to the foreign function. We can have handlers for single exception, multiple exceptions or
for all non fatal errors similar to Scala&rsquo;s
<a href="https://github.com/scala/scala/blob/2.12.x/src/library/scala/util/control/NonFatal.scala">NonFatal</a>.</p>

<h4>6. Constructors</h4>

<pre><code class="haskell">do
  arrayList1 &lt;- (arrayListClass &lt;.&gt; "&lt;init&gt;(int)") 10
  putStrLn !(either throw toString arrayList1)

  -- Unsafe constructor
  arrayList2 &lt;- arrayListClass &lt;.!&gt; "&lt;init&gt;()"
  putStrLn !(toString arrayList2)
</code></pre>

<p>Similar to methods, constructors can be overloaded and we can select a particular overload variant by explicitly
specifying the foreign type. Constructors can also be invoked in a safe or unsafe way. As constructors cannot return
null, when invoked in a safe way, the result type will only be in <code>Either</code> and not wrapped in a <code>Maybe</code>.</p>

<h4>7. Fields</h4>

<pre><code class="haskell">do
  -- static field getter
  caseInsensitiveComparator &lt;- stringClass &lt;.#!&gt; "CASE_INSENSITIVE_ORDER"
  printLn !((comparatorClass &lt;.!&gt; "compare") caseInsensitiveComparator "Bar" "august")

  point &lt;- (pointClass &lt;.!&gt; "&lt;init&gt;(int,int)") 2 3

  -- instance field getter
  printLn !((pointClass &lt;.#&gt; "x") point)

  -- instance field setter
  (pointClass &lt;.=&gt; "x") point 34
  printLn !((pointClass &lt;.#&gt; "x") point)
</code></pre>

<p>Similar to methods and constructors, fields can also be accessed either in a safe or unsafe way using <code>&lt;.#&gt;</code> for safe
getter, <code>&lt;.=&gt;</code> for safe setter, <code>&lt;.#!&gt;</code> for unsafe getter and <code>&lt;.=!&gt;</code> for unsafe setter. Since field access
cannot throw a exception, the return type is automatically just <code>Maybe nativeTy</code>. The field types are automatically
determined without the user having to provide the foreign types of the fields.</p>

<h2>Summary</h2>

<p>This post demonstrated how with Idris' powerful features FFI, type provider and elaborator reflection, we can safely and
easily access JVM foreign functions. We can access fields, methods and constructors without having to explicitly provide
foreign types and we can access them in safe way without <code>null</code> getting into Idris code and handle exceptions thrown by
foreign functions. It also showed how to call overloaded methods and constructors and how <code>Maybe</code> and <code>Either</code> types are
used with foreign functions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Idris JVM: Guarding Against Java Null Using Maybe Type]]></title>
    <link href="http://mmhelloworld.github.io/blog/2017/01/10/idris-jvm-guarding-against-java-null-using-maybe-type/"/>
    <updated>2017-01-10T21:08:00-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2017/01/10/idris-jvm-guarding-against-java-null-using-maybe-type</id>
    <content type="html"><![CDATA[<p>Idris JVM now helps avoiding nulls getting into Idris from FFI calls using <code>Maybe</code> type.
FFI declarations can have <code>Maybe</code> type in any argument position or in the return type.</p>

<h2>Handling <code>null</code> from FFI call</h2>

<pre><code class="haskell">getProperty : String -&gt; JVM_IO (Maybe String)
getProperty = invokeStatic SystemClass "getProperty" (String -&gt; JVM_IO (Maybe String))
</code></pre>

<p>The above function is an FFI call to Java&rsquo;s method
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperty-java.lang.String-"><code>static String getProperty(String key)</code></a>.
The method returns a system property value if the property is set otherwise returns null.
With <code>Maybe</code> type in the Idris function&rsquo;s return type, the Idris function returns <code>Nothing</code> if the returned value is null
otherwise the value is wrapped in <code>Just</code>.</p>

<h6>Example</h6>

<pre><code class="haskell returningnull.idr">module Main

import IdrisJvm.IO
import Java.Lang

main : JVM_IO ()
main = printLn !(getProperty "foo")  
</code></pre>

<pre><code class="bash">$ idris --portable-codegen jvm -p idrisjvmffi returningnull.idr -o target

$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main
Nothing

$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar -Dfoo=hello main.Main
Just "hello"
</code></pre>

<h2>Passing <code>Maybe</code> values for nullable values in FFI calls</h2>

<pre><code class="haskell passingnull.idr">module Main

import IdrisJvm.IO
import Java.Lang

namespace Component
  Component : Type
  Component = JVM_Native $ Class "java/awt/Component"

namespace JOptionPane
  JOptionPaneClass : JVM_NativeTy
  JOptionPaneClass = Class "javax/swing/JOptionPane"

  showMessageDialog : Inherits Object messageTy =&gt; Maybe Component -&gt; messageTy -&gt; JVM_IO ()
  showMessageDialog parent message =
    invokeStatic JOptionPaneClass "showMessageDialog" (Maybe Component -&gt; Object -&gt; JVM_IO ()) parent (believe_me message)

main : JVM_IO ()
main = showMessageDialog Nothing "Hello Idris!"
</code></pre>

<p>In the above code, the Java method
<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JOptionPane.html#showMessageDialog-java.awt.Component-java.lang.Object-"><code>JOptionPane.showMessageDialog(parentComponent, message)</code></a>
takes a nullable parent component and a message. If the parent component is <code>null</code> then the message is displayed in a default frame.</p>

<pre><code>$ idris --portable-codegen jvm -p idrisjvmffi passingnull.idr -o target

$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main
</code></pre>

<p>Idris code passes <code>Nothing</code> in the above code so <code>null</code> is passed for the Java method that displays the message in a default frame as shown below.
<img class="center" src="/images/idris-passing-null.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Idris on the JVM and an Idris Android Example]]></title>
    <link href="http://mmhelloworld.github.io/blog/2017/01/06/introducing-idris-on-the-jvm-and-an-idris-android-example/"/>
    <updated>2017-01-06T22:51:00-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2017/01/06/introducing-idris-on-the-jvm-and-an-idris-android-example</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/mmhelloworld/idris-jvm">Idris on the JVM!</a> Yes, a dependently typed language on the JVM!
I have been working on a <a href="https://github.com/mmhelloworld/idris-jvm">JVM bytecode backend for Idris</a> for the past few months and
it is now at a point that we can even write Android programs with Idris without having to write a single line of Java.
In this post, we will see how Idris works on the JVM and an example Android program written in Idris.</p>

<h2>Hello World</h2>

<pre><code class="haskell hellworld.idr">module Main

main : IO ()
main = printLn "Hello World"
</code></pre>

<h6>Compile:</h6>

<pre><code class="bash">$ idris --portable-codegen jvm -p idrisjvmffi helloworld.idr -o target
</code></pre>

<p>Dependencies are provided as Idris packages, not as Java dependencies like jar or class files.
The overall process is that the compiler reads Idris files and converts them into an intermediate JSON representation and
the JVM bytecode generator takes the JSON files and converts them into JVM bytecode class files directly.
It is only when we run a Java class, we have to provide Java dependency jars. The output option <code>-o</code> represents a directory
where the Java class files will be created.</p>

<h6>Run:</h6>

<pre><code class="bash">$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main
"Hello World"
</code></pre>

<p>And the output folder contains,</p>

<pre><code class="bash">$ tree target
target
├── Decidable
│   └── Equality.class
├── main
│   └── Main.class
└── Prelude
    ├── Basics.class
    ├── Bool.class
    ├── Chars.class
    ├── Interfaces.class
    ├── Show.class
    └── Strings.class
</code></pre>

<p>Why do we have all these classes? We only compiled <code>Main</code> module! This is because Idris performs whole program analysis/compilation
and code generator generates bytecode for all the modules that are relevant for the result produced by the main program.</p>

<h2>How does Idris JVM handle tail calls?</h2>

<p>Idris JVM eliminates self-recursion with JVM <code>GOTO</code> and uses trampolines for other tail calls.
Let&rsquo;s look at the following examples.</p>

<h5>self-recursion example</h5>

<pre><code class="haskell selfrecursion.idr">module Main

import IdrisJvm.IO

sum : Nat -&gt; Nat
sum n = go 0 n where
  go : Nat -&gt; Nat -&gt; Nat
  go acc Z = acc
  go acc n@(S k) = go (acc + n) k

main : JVM_IO ()
main = printLn (sum 50000)
</code></pre>

<p>This program would work just fine without blowing up the stack as it will be compiled down to a loop that uses JVM&rsquo;s <code>GOTO</code> instruction.
Here is the relevant section from bytecode:</p>

<pre><code class="bash">$ javap -c -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main

  public static java.lang.Object sum$whr$go$colon$0(java.lang.Object, java.lang.Object, java.lang.Object);
    Code:
       0: aconst_null
       1: astore        7
       3: aconst_null
       4: astore_3
       5: aconst_null
       6: astore        4
       8: aconst_null
       9: astore        5
      11: aconst_null
      12: astore        6
      14: iconst_1
      15: istore        8
      17: iload         8
      19: ifeq          130
      22: aload_2
      23: new           #80                 // class java/math/BigInteger
      26: dup
      27: ldc           #82                 // String 0
      29: invokespecial #85                 // Method java/math/BigInteger."&lt;init&gt;":(Ljava/lang/String;)V
      32: invokestatic  #333                // Method mmhelloworld/idrisjvmruntime/Util.equals:(Ljava/lang/Object;Ljava/lang/Object;)Z
      35: ifeq          47
      38: aload_1
      39: astore        7
      41: iconst_0
      42: istore        8
      44: goto          127
      47: new           #80                 // class java/math/BigInteger
      50: dup
      51: ldc_w         #335                // String 1
      54: invokespecial #85                 // Method java/math/BigInteger."&lt;init&gt;":(Ljava/lang/String;)V
      57: astore_3
      58: aload_2
      59: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
      62: aload_3
      63: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
      66: invokevirtual #338                // Method java/math/BigInteger.subtract:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
      69: astore_3
      70: new           #80                 // class java/math/BigInteger
      73: dup
      74: ldc_w         #335                // String 1
      77: invokespecial #85                 // Method java/math/BigInteger."&lt;init&gt;":(Ljava/lang/String;)V
      80: astore        4
      82: aload_3
      83: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
      86: aload         4
      88: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
      91: invokevirtual #107                // Method java/math/BigInteger.add:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
      94: astore        4
      96: iconst_0
      97: invokestatic  #41                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
     100: astore        5
     102: aload_1
     103: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
     106: aload         4
     108: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
     111: invokevirtual #107                // Method java/math/BigInteger.add:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
     114: astore        6
     116: aload         5
     118: astore_0
     119: aload         6
     121: astore_1
     122: aload_3
     123: astore_2
     124: goto          127
     127: goto          17
     130: aload         7
     132: areturn
</code></pre>

<p>The third line from the last is the <code>GOTO</code> instruction that transfers the control back to the top of function instead of
actually calling the function.</p>

<h5>Mutual recursion example:</h5>

<pre><code class="haskell mutualrecursion.idr">module Main

mutual
  evenT : Nat -&gt; IO Bool
  evenT Z = pure True
  evenT (S k) = oddT k

  oddT : Nat -&gt; IO Bool
  oddT Z = pure False
  oddT (S k) = evenT k

main : IO ()
main = printLn !(evenT 9999)
</code></pre>

<p>The above code also would work fine without killing the stack. Mutual recursion is handled using trampolines and
the tail calls are delayed and compiled down to Java 8 lambdas. As the bytecode for this is bit long, here is the
decompiled bytecode for the <code>evenT</code> function:</p>

<pre><code class="java Decompiled bytecode for evenT">    public static Object evenT(Object var0) {
        Object var4 = null;
        Integer var1 = null;
        Integer var2 = null;
        IdrisObject var3 = null;
        if (Util.equals(var0, BigInteger.ZERO)) {
            var1 = Integer.valueOf(0);
            var2 = Integer.valueOf(0);
            var3 = new IdrisObject(1);
            var4 = new IdrisObject(65653, new Object[]{var1, var2, var3});
        } else {
            BigInteger var5 = BigInteger.ONE;
            var5 = Util.asBigInt(var0).subtract(Util.asBigInt(var5));
            var4 = () -&gt; {
                return oddT(var5);
            };
        }

        return var4;
    }
</code></pre>

<p>As we can see from the decompiled output above, the <code>oddT</code> call is not performed on the same call stack but a thunk
wrapping the function call is returned using lambda (which is compiled down to JVM&rsquo;s <code>invokedynamic</code> instruction).</p>

<p>Here is the relevant bit from bytecode for those who are interested:</p>

<pre><code class="java bytecode for evenT">        68: getstatic     #64                 // Field java/math/BigInteger.ONE:Ljava/math/BigInteger;
        71: astore_1
        72: aload_0
        73: invokestatic  #68                 // Method io/github/mmhelloworld/idrisjvm/runtime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
        76: aload_1
        77: invokestatic  #68                 // Method io/github/mmhelloworld/idrisjvm/runtime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
        80: invokevirtual #72                 // Method java/math/BigInteger.subtract:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
        83: astore_1
        84: aload_1
        85: invokedynamic #79,  0             // InvokeDynamic #1:call:(Ljava/lang/Object;)Lio/github/mmhelloworld/idrisjvm/runtime/Thunk;
        90: astore        4
        92: goto          95
        95: aload         4
        97: areturn
</code></pre>

<h2>Java interoperability: Calling Java from Idris and calling Idris from Java</h2>

<p>Idris JVM supports calling Java static methods, instance methods, constructors and also accessing static and instance fields from Idris.
At the moment, except for Java arrays, all the Java types can be constructed from Idris and passed to Java methods.
Support for handling nulls and exceptions is currently in progress and will soon be available.
(Update 01/10/2017: We can now
<a href="http://mmhelloworld.github.io/blog/2017/01/10/idris-jvm-guarding-against-java-null-using-maybe-type/">use <code>Maybe</code> type to avoid Java nulls</a>
in Idris code)</p>

<p>To use Idris functions from Java, Idris JVM supports exporting Idris functions as static methods, instance methods,
constructors of an exported Java class. The exported class can also extend a Java class or implement interfaces with Idris functions.</p>

<p>To demonstrate these features, let&rsquo;s create an Android application In Idris.</p>

<h3>An Android application in Idris</h3>

<pre><code class="haskell idrisandroid.idr">module Main

import IdrisJvm.IO
import Java.Lang

pythag : Int -&gt; List (Int, Int, Int)
pythag max = [(x, y, z) | z &lt;- [1..max], y &lt;- [1..z], x &lt;- [1..y],
                          x * x + y * y == z * z]

IdrisAndroidActivity : Type
IdrisAndroidActivity = JVM_Native $ Class "hello/IdrisAndroidActivity"

Bundle : Type
Bundle = JVM_Native $ Class "android/os/Bundle"

Context : Type
Context = JVM_Native $ Class "android/content/Context"

View : Type
View = JVM_Native $ Class "android/view/View"

TextView : Type
TextView = JVM_Native $ Class "android/widget/TextView"

Inherits View TextView where {}

CharSequence : Type
CharSequence = JVM_Native $ Class "java/lang/CharSequence"

Inherits CharSequence String where {}

superOnCreate : IdrisAndroidActivity -&gt; Bundle -&gt; JVM_IO ()
superOnCreate = invokeInstance "superOnCreate" (IdrisAndroidActivity -&gt; Bundle -&gt; JVM_IO ())

getApplicationContext : IdrisAndroidActivity -&gt; JVM_IO Context
getApplicationContext = invokeInstance "getApplicationContext" (IdrisAndroidActivity -&gt; JVM_IO Context)

newTextView : Context -&gt; JVM_IO TextView
newTextView = FFI.new (Context -&gt; JVM_IO TextView)

setText : Inherits CharSequence charSequence =&gt; TextView -&gt; charSequence -&gt; JVM_IO ()
setText this text = invokeInstance "setText" (TextView -&gt; CharSequence -&gt; JVM_IO ()) this (believe_me text)

setContentView : Inherits View view =&gt; IdrisAndroidActivity -&gt; view -&gt; JVM_IO ()
setContentView this view = invokeInstance "setContentView" (IdrisAndroidActivity -&gt; View -&gt; JVM_IO ()) this (believe_me view)

onCreate : IdrisAndroidActivity -&gt; Bundle -&gt; JVM_IO ()
onCreate this bundle = do
  superOnCreate this bundle
  context &lt;- getApplicationContext this
  textView &lt;- newTextView context
  setText textView $ "Hello Android from Idris! pythag 50 is " ++ show (pythag 50)
  setContentView this textView

main : IO ()
main = pure ()

androidExport: FFI_Export FFI_JVM "hello/IdrisAndroidActivity extends android/support/v7/app/AppCompatActivity" []
androidExport =
  Fun superOnCreate (Super "onCreate") $
  Fun onCreate (ExportInstance "onCreate") $
  End
</code></pre>

<p>The above program demonstrates calling Java instance methods (<code>setText</code> for example) and constructors (<code>newTextView</code>).</p>

<p>It further demonstrates how to handle inheritance relationship when passing subclass instances to a parent class type.
For example, function <code>setContentView</code> takes a <code>View</code> but we can pass a <code>TextView</code> as it is a subclass of <code>View</code> and we
mention that to Idris via <code>Inherits View TextView where {}</code>.</p>

<p>It also demonstrates how we can create a Java class that extends another class and override methods with Idris functions.
The last section <code>androidExport</code> creates a Java class named <code>hello/IdrisAndroidActivity</code> that extends <code>android/support/v7/app/AppCompatActivity</code>.
The Java class also creates a wrapper method <code>superOnCreate</code> that just delegates to <code>super.OnCreate</code> and the class also overrides <code>onCreate</code> method
with Idris' <code>onCreate</code> function. The Java class can also implement one or more Java interfaces with something like,</p>

<pre><code class="bash">hello/IdrisAndroidActivity extends android/support/v7/app/AppCompatActivity implements java/lang/Runnable, java/lang/Comparable
</code></pre>

<p>A module can have multiple exports so we can actually create multiple Java classes with Idris implementation functions from an Idris module.</p>

<p>We can compile this as usual,</p>

<p><code>idris --portable-codegen jvm -p idrisjvmffi idrisandroid.idr -o target</code></p>

<p>It would produce the following class files:</p>

<pre><code>$ tree target/
target/
├── Decidable
│   └── Equality.class
├── hello
│   └── IdrisAndroidActivity.class
├── main
│   ├── Main.class
│   └── Prelude.class
└── Prelude
    ├── Algebra.class
    ├── Applicative.class
    ├── Bool.class
    ├── Foldable.class
    ├── Interfaces.class
    ├── List.class
    ├── Monad.class
    ├── Show.class
    └── Strings.class
</code></pre>

<h5>Deploying to Android:</h5>

<ol>
<li>Create an android project using Android studio with <a href="https://developer.android.com/guide/platform/j8-jack.html#configuration">Jack support for Java 8</a>.</li>
<li>Then package the classes compiled above along with idris-jvm-runtime-1.0-SNAPSHOT.jar classes in a single jar and copy into an
android project&rsquo;s <code>app/libs</code> directory.</li>
<li>Change the activity class name in android manifest file to the Idris exported class name <code>hello.IdrisAndroidActivity</code>.</li>
<li>Then run <code>./gradlew installDebug</code> from android project after starting an emulator or connected to an android device.</li>
<li>Finally we should see our Idris code running on Android! It should look something like this:
<img class="center" src="/images/idris-android.png"></li>
</ol>


<p>Happy coding!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Frege: Hello Java]]></title>
    <link href="http://mmhelloworld.github.io/blog/2013/07/10/frege-hello-java/"/>
    <updated>2013-07-10T11:00:00-04:00</updated>
    <id>http://mmhelloworld.github.io/blog/2013/07/10/frege-hello-java</id>
    <content type="html"><![CDATA[<p>Here is a small code demonstrating Java interoperability in Frege:</p>

<p><figure class='code'><figcaption><span>Calling Java from Frege  (HelloJava.fr)</span> <a href='/downloads/code/HelloJava.fr'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="err">hellojava.</span><span class="nn">HelloJava</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">data</span> <span class="kt">LinkedList</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">native</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="kt">LinkedList</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">native</span> <span class="n">add</span> <span class="ow">::</span> <span class="kt">Mutable</span> <span class="n">s</span> <span class="p">(</span><span class="kt">LinkedList</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="kt">Bool</span>
</span><span class='line'>    <span class="n">native</span> <span class="n">get</span> <span class="ow">::</span> <span class="kt">Mutable</span> <span class="n">s</span> <span class="p">(</span><span class="kt">LinkedList</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="n">throws</span>
</span><span class='line'>        <span class="kt">IndexOutOfBoundsException</span>
</span><span class='line'>    <span class="n">native</span> <span class="n">new</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">STMutable</span> <span class="n">s</span> <span class="p">(</span><span class="kt">LinkedList</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">fromFregeList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">STMutable</span> <span class="n">s</span> <span class="p">(</span><span class="kt">LinkedList</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'>    <span class="n">fromFregeList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">LinkedList</span><span class="o">.</span><span class="n">new</span> <span class="nb">()</span> <span class="o">&gt;&gt;=</span> <span class="n">loop</span> <span class="n">xs</span> <span class="kr">where</span>
</span><span class='line'>        <span class="n">loop</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">jlist</span> <span class="ow">=</span> <span class="kt">LinkedList</span><span class="o">.</span><span class="n">add</span> <span class="n">jlist</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">loop</span> <span class="n">xs</span> <span class="n">jlist</span>
</span><span class='line'>        <span class="n">loop</span> <span class="kt">[]</span> <span class="n">jlist</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">jlist</span>
</span><span class='line'>
</span><span class='line'><span class="nf">plusTop</span> <span class="ow">::</span> <span class="kt">Mutable</span> <span class="n">s</span> <span class="p">(</span><span class="kt">LinkedList</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span>
</span><span class='line'><span class="nf">plusTop</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">do</span>
</span><span class='line'>    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="o">.</span><span class="n">get</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="o">.</span><span class="n">get</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">return</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">a</span> <span class="o">&lt;*&gt;</span> <span class="n">b</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kr">data</span> <span class="kt">IndexOutOfBoundsException</span> <span class="ow">=</span> <span class="n">native</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="kt">IndexOutOfBoundsException</span>
</span><span class='line'><span class="nf">derive</span> <span class="kt">Exceptional</span> <span class="kt">IndexOutOfBoundsException</span>
</span><span class='line'>
</span><span class='line'><span class="kr">data</span> <span class="kt">Exception</span> <span class="ow">=</span> <span class="n">native</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="kt">Exception</span>
</span><span class='line'><span class="nf">derive</span> <span class="kt">Exceptional</span> <span class="kt">Exception</span>
</span><span class='line'>
</span><span class='line'><span class="kr">data</span> <span class="kt">NullPointerException</span> <span class="ow">=</span> <span class="n">native</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="kt">NullPointerException</span>
</span><span class='line'><span class="nf">derive</span> <span class="kt">Exceptional</span> <span class="kt">NullPointerException</span>
</span><span class='line'>
</span><span class='line'><span class="nf">pure</span> <span class="n">native</span> <span class="n">showThrowable</span> <span class="n">toString</span> <span class="ow">::</span> <span class="kt">Throwable</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</span><span class='line'>
</span><span class='line'><span class="nf">main</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kr">do</span>
</span><span class='line'>    <span class="n">javaList</span> <span class="ow">&lt;-</span> <span class="kt">LinkedList</span><span class="o">.</span><span class="n">fromFregeList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class='line'>    <span class="n">try</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">plusTop</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="n">println</span> <span class="o">.</span> <span class="n">maybe</span> <span class="s">&quot;Got a null pointer&quot;</span> <span class="n">show</span><span class="p">))</span> <span class="n">javaList</span>
</span><span class='line'>        <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">npe</span> <span class="ow">::</span> <span class="kt">NullPointerException</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">println</span> <span class="o">$</span> <span class="n">showThrowable</span> <span class="n">npe</span><span class="p">)</span>
</span><span class='line'>        <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">exception</span> <span class="ow">::</span> <span class="kt">Exception</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">println</span> <span class="o">$</span> <span class="n">showThrowable</span> <span class="n">exception</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>We can observe the following things from the above code:</p>

<ol>
<li>Making use of a Java class and its methods</li>
<li>Using a Java object in a Frege function</li>
<li>Using Java Exceptions in functions</li>
<li>Handling Java exceptions</li>
</ol>


<h3>1. Making use of a Java class and its methods:</h3>

<p>If a Java class is pure then without much effort, we can use that class in Frege. For example,</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Integer</span> <span class="ow">=</span> <span class="n">native</span> <span class="n">java</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="kt">BigInteger</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">pure</span>  <span class="n">native</span> <span class="n">abs</span>                                  <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
</span><span class='line'>    <span class="n">pure</span>  <span class="n">native</span> <span class="n">negate</span>                               <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
</span><span class='line'>    <span class="n">pure</span>  <span class="n">native</span> <span class="n">valueOf</span> <span class="n">java</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="kt">BigInteger</span><span class="o">.</span><span class="n">valueOf</span> <span class="ow">::</span> <span class="kt">Long</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>A Java class is declared with <code>data</code> declaration in Frege. The identifier after the <code>data</code> keyword
is the corresponding type for the Java class in Frege and the qualified Java class is identified after the <code>native</code>
keyword followed by the instance methods, static methods or even some Frege functions not defined in the
original Java class.</p>

<p>An important point here is that the instance methods on BigInteger take Integer as their
first argument which is the <code>this</code> reference on which the methods will be invoked.</p>

<p>Coming back to our original example, here
we are trying to use the mutable Java class <code>java.util.LinkedList</code>.
An obvious difference between this one and the <code>BigInteger</code> example is that the
functions now do not have the <code>pure</code> keyword in front.</p>

<p>The next difference is that the instance methods now cannot take the simple type like <code>LinkedList a</code> as we did for
<code>Integer</code> but the type is now <code>Mutable s (LinkedList a)</code> since it is not a pure function.
If we don&rsquo;t annotate a native function <code>pure</code> and we don&rsquo;t use <code>Mutable</code> to consume or return a mutable Object, it will be a
compilation error. Mutable objects can only be used in <code>ST</code> or <code>IO</code> actions so the return type
must be in ST or IO monad.</p>

<p>The <a href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html#add(E)">LinkedList.add()</a> method returns a boolean. Since
it is an impure function, it should be used in <code>ST</code> monad. Here the boolean itself is pure so it is just <code>ST s Bool</code>.
Take a look at the third function <code>new</code>, <code>LinkedList</code> constructor. This function is impure and it returns
a mutable object, a new <code>LinkedList</code> instance, so the return type is <code>ST s (Mutable s (LinkedList a))</code> for which the shorthand is <code>STMutable s (LinkedList a)</code>.</p>

<p>Here is an example for a native function not being part of a native
<code>data</code> declaration. This is useful when a native class is already
declared in Frege in some module but the function that we are looking
for is missing in the <code>data</code> declaration.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">pure</span> <span class="n">native</span> <span class="n">showThrowable</span> <span class="n">toString</span> <span class="ow">::</span> <span class="kt">Throwable</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Here <code>showThrowable</code> is the Frege function name for <code>Throwable.toString()</code>. Since it is an
instance method on <code>Throwable</code>, the first argument is of type
<code>Throwable</code> and then the formal arguments' types (in this case, none) and return type.</p>

<h3>2. Using a Java object in a Frege function</h3>

<p>A native <code>data</code> declaration doesn&rsquo;t have to just contain the native members, it can also have
additional Frege functions.
In our example, the function <code>fromFregeList</code> is not defined in
the Java class but it has been added as an utility function to create a <code>LinkedList</code> from a frege list.
Here again the same rule as in the previous section applies: To return a mutable Java object,
we should use <code>ST s (Mutable s TheJavaType)</code> which is nothing but <code>STMutable s TheJavaType</code>.</p>

<p>In the same way, the <code>plusTop</code> function takes a mutable Java object so the parameter type is
<code>Mutable s (LinkedList Int)</code>. Also since it consumes a mutable type, it must be in <code>ST</code> monad hence
the return type is <code>ST s (Maybe Int)</code> returning an <code>Maybe Int</code> in <code>ST</code>.</p>

<h3>3. Using Java Exceptions in functions</h3>

<p>To use a Java Exception class, it must be first defined in a Frege
module. It is the same as declaring native declaration for a Java class but
additionally we need to derive the <code>Exceptional</code> type class so that the exception can later be handled with
<code>catch</code>.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">IndexOutOfBoundsException</span> <span class="ow">=</span> <span class="n">native</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="kt">IndexOutOfBoundsException</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">derive</span> <span class="kt">Exceptional</span> <span class="kt">IndexOutOfBoundsException</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>The exceptions can then be used in native declarations as in <code>get</code> function in our example:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">native</span> <span class="n">get</span> <span class="ow">::</span> <span class="kt">Mutable</span> <span class="n">s</span> <span class="p">(</span><span class="kt">LinkedList</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="n">throws</span>
</span><span class='line'>    <span class="kt">IndexOutOfBoundsException</span>
</span></code></pre></td></tr></table></div></figure></p>

<h3>4. Handling Java exceptions</h3>

<p>In two ways, we can handle exceptions:</p>

<ol>
<li><p>Using <code>action `catch` handler1 `catch` handler2</code></p>

<p>The type of <code>catch</code> is <code>Exceptional β =&gt; ST γ α -&gt; (β-&gt;ST γ α) -&gt; ST γ α</code>.</p>

<p>Here the <code>action</code> is the code where an exception might be thrown
and the handlers <code>handler1</code> and <code>handler2</code> take an exception and
return another value in <code>ST</code> monad. The infix notation facilitates
adding multiple handlers with better readability. Further here the
<code>handler1</code> must be more specific(in terms of the types of the
exceptions being handled) than <code>handler2</code>. Also note that from <a href="https://github.com/Frege/frege/blob/master/frege/prelude/PreludeIO.fr#L116">Frege standard library</a> with respect to <code>catch</code>:</p>

<blockquote><p><strong>Note</strong> If <em>action</em> is of the form:
   <code>doSomething arg</code>
then, depending on the strictness of <code>doSomething</code> the argument <code>arg</code> may be evaluated
<strong>before</strong> the action is returned. Exceptions (i.e. undefined values)
that occur in the construction of the action do <strong>not</strong> count as
exceptions thrown during execution of it, and hence cannot be catched.</p>

<p>Example:
<code>println (head []) `catch`  ....</code></p>

<p>will not catch the exception that will be thrown when println evaluates</p>

<p>For a remedy, see <code>try</code>.</p></blockquote></li>
<li><p>Using <code>try</code></p>

<p>First, the type: <code>try :: Monad γ =&gt; (α-&gt; γ β) -&gt; α -&gt; γ β</code></p>

<p>Unlike <code>catch</code>, <code>try</code> takes a function that produces a monadic value. If
the function can throw an exception, it must result in an <code>ST</code>
monad which can then be passed to <code>catch</code> to handle those
exceptions. In our example, <code>\xs -&gt; plusTop xs &gt;&gt;= (println . maybe "Got a null pointer"
show)</code> is the function which when applied to a
<code>java.util.LinkedList</code> might throw a <code>NullPointerException</code> or
<code>IndexOutOfBoundsException</code>:</p>

<p><figure class='code'><figcaption><span>Using try </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">try</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">plusTop</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="n">println</span> <span class="o">.</span> <span class="n">maybe</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="kt">Got</span> <span class="n">a</span> <span class="n">null</span> <span class="n">pointer</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="n">show</span><span class="p">))</span> <span class="n">javaList</span>
</span><span class='line'>    <span class="n">catch</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">npe</span> <span class="ow">::</span> <span class="kt">NullPointerException</span><span class="p">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">println</span> <span class="o">$</span> <span class="n">showThrowable</span> <span class="n">npe</span><span class="p">)</span>
</span><span class='line'>    <span class="n">catch</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="p">((</span><span class="n">exception</span> <span class="ow">::</span> <span class="kt">Exception</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">println</span> <span class="o">$</span> <span class="n">showThrowable</span> <span class="n">exception</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></p></li>
</ol>


<p>Since the construction of action is deferred through a lambda
here, <code>try</code> eliminates the issue with <code>catch</code> mentioned in the above note.</p>

<h3>Extending a class or implementing an interface in Frege:</h3>

<p>One thing that is not shown in the example is extending a Java class
or implementing an interface in Frege. Unfortunately both are not possible in Frege
yet. There is a workaround though using a Java class which extends a
class or implements an interface but instead of an implementation on
its own, it just delegates to a Frege function. For example, see
<a href="https://github.com/Frege/frege/blob/master/frege/java/Lang.fr#L89">here</a>
for implementing <code>java.lang.Runnable</code> in Frege using a Java class
<a href="https://github.com/Frege/frege/blob/master/frege/runtime/SwingSupport.java#L56">frege.runtime.SwingSupport</a> which takes a Frege function and then
delegates to it in <code>run</code> method implementation.</p>

<p>This concludes our little experimentation calling Java from Frege. The
other interesting side, calling Frege from Java, is for a
future post.</p>
]]></content>
  </entry>
  
</feed>
