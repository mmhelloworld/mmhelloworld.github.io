<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Idris | mmhelloworld]]></title>
  <link href="http://mmhelloworld.github.io/blog/categories/idris/atom.xml" rel="self"/>
  <link href="http://mmhelloworld.github.io/"/>
  <updated>2018-02-11T02:28:20-05:00</updated>
  <id>http://mmhelloworld.github.io/</id>
  <author>
    <name><![CDATA[Marimuthu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Idris JVM: Automated FFI with null safety and exception handling]]></title>
    <link href="http://mmhelloworld.github.io/blog/2018/02/11/idris-jvm-automated-ffi-with-null-safety/"/>
    <updated>2018-02-11T00:03:00-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2018/02/11/idris-jvm-automated-ffi-with-null-safety</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>Idris JVM backend has supported foreign function calls for some time now. For example, to invoke <code>parseInt</code> method on
<code>java.lang.Integer</code> class,</p>

<p><code>haskell
invokeStatic (Class "java/lang/Integer") "parseInt" (String -&gt; JVM_IO Int) "234"
</code></p>

<p>Here since the Idris compiler doesn&rsquo;t know anything about Java&rsquo;s <code>Integer</code> class or its <code>parseInt</code> method, we have to
explicitly provide the function signature. The function call also has the explicit <code>Class</code>
before <code>java/lang/Integer</code> and the type of invocation <code>invokeStatic</code>.</p>

<p>Since we are targeting JVM bytecode, JVM has to know whether a method call is a static method call or an interface
method call or a virtual method call. It would be nice if we don&rsquo;t have to worry about any of these things and
just call a FFI function with a class name, method name and the arguments. This is the motivation behind this
new feature along with some other nice things like null safety, construtor and method overloading resolution
and exception handling.</p>

<h4>Maybe and Either in foreign function calls</h4>

<p><code>Maybe</code> type and <code>Either</code> type can be used in foreign function calls for null safety and exception handling. <code>Maybe</code>
type can be used for argument types and return types. <code>Maybe</code> type used in an argument position will pass <code>null</code>
to the target foreign function if it is <code>Nothing</code> or the actual value if it is <code>Just</code>. Similarly, <code>Maybe</code> type
used for return type will convert <code>null</code> returned from foreign function into <code>Nothing</code> and the non-null value into
<code>Just.</code> At the bytecode level, <code>Maybe</code> wrapper doesn&rsquo;t exist. It gets compiled down to
<code>null</code> or the actual value.</p>

<p><code>Either</code> type can only be used in return types to indicate whether the foreign function can throw exceptions.
At runtime, if the foreign function throws exception, it will be captured in the &ldquo;left&rdquo; of type <code>Throwable</code> or if the
foreign function completes normally, the result will be stored in the &ldquo;right&rdquo; of result type. There are functions <code>try</code>
and <code>catch</code> to handle exceptions which we will see later in the post.</p>

<h2>How it works</h2>

<p>Before we look at some examples, first let&rsquo;s declare some class names as we are going to use them in multiple places and
we don&rsquo;t want to duplicate.</p>

<p>```haskell
stringClass: String
stringClass = &ldquo;java/lang/String&rdquo;</p>

<p>listInterface: String
listInterface = &ldquo;java/util/List&rdquo;</p>

<p>arrayListClass: String
arrayListClass = &ldquo;java/util/ArrayList&rdquo;</p>

<p>collectionInterface : String
collectionInterface = &ldquo;java/util/Collection&rdquo;</p>

<p>systemClass: String
systemClass = &ldquo;java/lang/System&rdquo;</p>

<p>comparatorClass : String
comparatorClass = &ldquo;java/util/Comparator&rdquo;</p>

<p>pointClass : String
pointClass = &ldquo;java/awt/Point&rdquo;</p>

<p>collectionsClass : String
collectionsClass = &ldquo;java/util/Collections&rdquo;</p>

<p>stringBuilderClass : String
stringBuilderClass = &ldquo;java/lang/StringBuilder&rdquo;</p>

<p>objectsClass : String
objectsClass = &ldquo;java/util/Objects&rdquo;</p>

<p>integerClass : String
integerClass = &ldquo;java/lang/Integer&rdquo;
```</p>

<p>And &ldquo;import&rdquo; some methods:</p>

<p>```haskell
jdkimport [</p>

<pre><code>(systemClass, ["getProperty", "setProperty"]),
(stringClass, ["substring", "CASE_INSENSITIVE_ORDER", "valueOf"]),
(integerClass, ["parseInt"]),
(comparatorClass, ["compare"]),
(arrayListClass, ["&lt;init&gt;", "add"]),
(listInterface, ["get"]),
(collectionsClass, ["max"]),
(stringBuilderClass, ["&lt;init&gt;", "toString"]),
(objectsClass, ["toString"]),
(pointClass, ["&lt;init&gt;", "x"])
</code></pre>

<p>  ]
<code>``
Here</code>jdkimport<code>is just an additional syntax created using Idris syntax extensions. It just calls a type provider
function written in Idris to know about these classes, methods and fields. Note that it imports fields such as
</code>CASE_INSENSITIVE_ORDER<code>,</code>x<code>and also constructors in the name of</code><init><code>which is the JVM internal name for
constructors. The</code>jdkimport` syntax launches a JVM during compilation without any classpath so it basically can import
all the JDK classes and methods.</p>

<p>There is also another syntax called <code>jvmimport</code> that can take an additional argument, a command, which could be just the
JVM with correct classpath or could be a build tool that properly sets up the classpath from your project dependencies so
that we can &ldquo;import&rdquo; classes and methods from external foreign libraries.</p>

<p>Once the information about JVM classes and methods is collected using type provider, appropriate call site, Idris code
similar to the one in the beginning of the post can be created using Idris elaborator reflection with just class name
and member name from the user. As a user, we don&rsquo;t have to know much about these internals, we just need to import classes
and members and can use them without having to explicitly provide foreign types. Now let&rsquo;s look at some examples on how we can
actually make FFI calls in the new way.</p>

<h2>Examples</h2>

<h4>1. Safe static method call</h4>

<p><code>haskell
main : JVM_IO ()
main = do
  exceptionOrInt &lt;- (integerClass &lt;.&gt; "parseInt") "1234"
  printLn $ either (const 0) id exceptionOrInt
</code>
Here the type of <code>(integerClass &lt;.&gt; "parseInt")</code> is <code>String -&gt; JVM_IO (Either Throwable Int)</code>. Since the method can throw
exceptions, it returns an <code>Either</code>. Here we return <code>0</code> in case of an exception. Later in the post, we will see a
detailed example of exception handling. As the method returns an <code>Int</code> which is a primitive type in JVM, it cannot be
null and the FFI call already knows that hence the result <code>Int</code> is not wrapped in a <code>Maybe</code>. We don&rsquo;t provide any
explicit type signature for the foreign function. If we try to pass anything other than <code>String</code> for this foreign
function, it will be a compilation error!</p>

<h4>2. Unsafe static method call</h4>

<p>```haskell
  do</p>

<pre><code>number &lt;- (integerClass &lt;.!&gt; "parseInt") "23"
printLn number
</code></pre>

<p><code>``
Here we use</code>&lt;.!><code>with an</code>!<code>to indicate an unsafe method call instead of</code>&lt;.><code>. There is also</code>javaUnsafe<code>and</code>java<code>
if you prefer names to operators. The type of</code>(integerClass &lt;.!> &ldquo;parseInt&rdquo;)<code>is</code>String &ndash;> JVM_IO Int`.
Sometimes if we are sure that the foreign function would not return null or throw exceptions, we can use unsafe method
calls but as the name indicates, it would fail at runtime if null is returned or an exception is thrown.</p>

<h4>3. Overloading resolution</h4>

<p>We can pick which overloaded variant we want to use by passing appropriate types to the foreign function and
the FFI call will automatically have corresponding types.</p>

<p><code>haskell
printLn !((stringClass &lt;.!&gt; "valueOf(double)") 2.5)
printLn !((stringClass &lt;.!&gt; "valueOf(char)") 'H')
</code>
The first function takes an Idris <code>Double</code> and the second function takes Idris <code>Char</code>. The types passed to the foreign
functions to resolve overloading are JVM types.</p>

<h4>4. Safe instance method</h4>

<p>```haskell
  do</p>

<pre><code>s &lt;- (stringClass &lt;.&gt; "substring(int)") "Foobar" 1
putStrLn !(either throw (pure . show) s) 
</code></pre>

<p>```
Safe instance method calls are similar to static method calls except that the instance should be passed as the first
argument. Here again, we don&rsquo;t provide any explicit type signature or the type of method invocation whether it is static or
instance method but it all works out automatically in a type safe way. Here also we pick a particular overloaded version.</p>

<p>The type of <code>(stringClass &lt;.&gt; "substring(int)")</code> is <code>String -&gt; Int -&gt; JVM_IO (Either Throwable (Maybe String))</code>.
Since the return type is <code>String</code> and it can be null, it is in a <code>Maybe</code> and the method can throw exceptions so the
overall type is in <code>Either</code>.</p>

<h4>5. Exception handling</h4>

<p>```haskell
do
  propValue &lt;&ndash; try ((systemClass &lt;.> &ldquo;getProperty(?java/lang/String)&rdquo;) Nothing) [</p>

<pre><code>([catch IllegalArgumentExceptionClass, catch NullPointerExceptionClass], \t =&gt;
  do
    printLn "property name is null or empty"
    pure Nothing
),
([catchNonFatal], \t =&gt;
  do
    printLn "unable to get property value"
    pure Nothing
)
</code></pre>

<p>  ]
  printLn propValue
<code>``
This example shows how to handle exceptions with different handlers and also shows how to pass a</code>null<code>to a foreign function.
If a FFI function argument type is prefixed with</code>?<code>, then the idris type would be</code>Maybe nativeTy<code>and we can pass
</code>Nothing<code>to pass a</code>null` to the foreign function. We can have handlers for single exception, multiple exceptions or
for all non fatal errors similar to Scala&rsquo;s
<a href="https://github.com/scala/scala/blob/2.12.x/src/library/scala/util/control/NonFatal.scala">NonFatal</a>.</p>

<h4>6. Constructors</h4>

<p>```haskell
do
  arrayList1 &lt;&ndash; (arrayListClass &lt;.> &ldquo;<init>(int)&rdquo;) 10
  putStrLn !(either throw toString arrayList1)</p>

<p>  &mdash; Unsafe constructor
  arrayList2 &lt;&ndash; arrayListClass &lt;.!> &ldquo;<init>()&rdquo;
  putStrLn !(toString arrayList2)
<code>``
Similar to methods, constructors can be overloaded and we can select a particular overload variant by explicitly
specifying the foreign type. Constructors can also be invoked in a safe or unsafe way. As constructors cannot return
null, when invoked in a safe way, the result type will only be in</code>Either<code>and not wrapped in a</code>Maybe`.</p>

<h4>7. Fields</h4>

<p>```haskell
do
  &mdash; static field getter
  caseInsensitiveComparator &lt;&ndash; stringClass &lt;.#!> &ldquo;CASE_INSENSITIVE_ORDER&rdquo;
  printLn !((comparatorClass &lt;.!> &ldquo;compare&rdquo;) caseInsensitiveComparator &ldquo;Bar&rdquo; &ldquo;august&rdquo;)</p>

<p>  point &lt;&ndash; (pointClass &lt;.!> &ldquo;<init>(int,int)&rdquo;) 2 3</p>

<p>  &mdash; instance field getter
  printLn !((pointClass &lt;.#> &ldquo;x&rdquo;) point)</p>

<p>  &mdash; instance field setter
  (pointClass &lt;.=> &ldquo;x&rdquo;) point 34
  printLn !((pointClass &lt;.#> &ldquo;x&rdquo;) point)
<code>``
Similar to methods and constructors, fields can also be accessed either in a safe or unsafe way using</code>&lt;.#><code>for safe
getter,</code>&lt;.=><code>for safe setter,</code>&lt;.#!><code>for unsafe getter and</code>&lt;.=!><code>for unsafe setter. Since field access
cannot throw a exception, the return type is automatically just</code>Maybe nativeTy`. The field types are automatically
determined without the user having to provide the foreign types of the fields.</p>

<h2>Summary</h2>

<p>This post demonstrated how with Idris' powerful features FFI, type provider and elaborator reflection, we can safely and
easily access JVM foreign functions. We can access fields, methods and constructors without having to explicitly provide
foreign types and we can access them in safe way without <code>null</code> getting into Idris code and handle exceptions thrown by
foreign functions. It also showed how to call overloaded methods and constructors and how <code>Maybe</code> and <code>Either</code> types are
used with foreign functions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Idris JVM: Guarding against Java null using Maybe type]]></title>
    <link href="http://mmhelloworld.github.io/blog/2017/01/10/idris-jvm-guarding-against-java-null-using-maybe-type/"/>
    <updated>2017-01-10T21:08:00-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2017/01/10/idris-jvm-guarding-against-java-null-using-maybe-type</id>
    <content type="html"><![CDATA[<p>Idris JVM now helps avoiding nulls getting into Idris from FFI calls using <code>Maybe</code> type.
FFI declarations can have <code>Maybe</code> type in any argument position or in the return type.</p>

<h2>Handling <code>null</code> from FFI call</h2>

<p><code>haskell
getProperty : String -&gt; JVM_IO (Maybe String)
getProperty = invokeStatic SystemClass "getProperty" (String -&gt; JVM_IO (Maybe String))
</code></p>

<p>The above function is an FFI call to Java&rsquo;s method
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperty-java.lang.String-"><code>static String getProperty(String key)</code></a>.
The method returns a system property value if the property is set otherwise returns null.
With <code>Maybe</code> type in the Idris function&rsquo;s return type, the Idris function returns <code>Nothing</code> if the returned value is null
otherwise the value is wrapped in <code>Just</code>.</p>

<h6>Example</h6>

<p>``` haskell returningnull.idr
module Main</p>

<p>import IdrisJvm.IO
import Java.Lang</p>

<p>main : JVM_IO ()
main = printLn !(getProperty &ldquo;foo&rdquo;)<br/>
```</p>

<p>``` bash
$ idris &mdash;portable-codegen jvm -p idrisjvmffi returningnull.idr -o target</p>

<p>$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main
Nothing</p>

<p>$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar -Dfoo=hello main.Main
Just &ldquo;hello&rdquo;</p>

<p>```</p>

<h2>Passing <code>Maybe</code> values for nullable values in FFI calls</h2>

<p>``` haskell passingnull.idr
module Main</p>

<p>import IdrisJvm.IO
import Java.Lang</p>

<p>namespace Component
  Component : Type
  Component = JVM_Native $ Class &ldquo;java/awt/Component&rdquo;</p>

<p>namespace JOptionPane
  JOptionPaneClass : JVM_NativeTy
  JOptionPaneClass = Class &ldquo;javax/swing/JOptionPane&rdquo;</p>

<p>  showMessageDialog : Inherits Object messageTy => Maybe Component &ndash;> messageTy &ndash;> JVM_IO ()
  showMessageDialog parent message =</p>

<pre><code>invokeStatic JOptionPaneClass "showMessageDialog" (Maybe Component -&gt; Object -&gt; JVM_IO ()) parent (believe_me message)
</code></pre>

<p>main : JVM_IO ()
main = showMessageDialog Nothing &ldquo;Hello Idris!&rdquo;</p>

<p>```</p>

<p>In the above code, the Java method
<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JOptionPane.html#showMessageDialog-java.awt.Component-java.lang.Object-"><code>JOptionPane.showMessageDialog(parentComponent, message)</code></a>
takes a nullable parent component and a message. If the parent component is <code>null</code> then the message is displayed in a default frame.</p>

<p>```
$ idris &mdash;portable-codegen jvm -p idrisjvmffi passingnull.idr -o target</p>

<p>$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main
<code>``
Idris code passes</code>Nothing<code>in the above code so</code>null` is passed for the Java method that displays the message in a default frame as shown below.
<img class="center" src="/images/idris-passing-null.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Idris on the JVM and an Idris Android example]]></title>
    <link href="http://mmhelloworld.github.io/blog/2017/01/06/introducing-idris-on-the-jvm-and-an-idris-android-example/"/>
    <updated>2017-01-06T22:51:00-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2017/01/06/introducing-idris-on-the-jvm-and-an-idris-android-example</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/mmhelloworld/idris-jvm">Idris on the JVM!</a> Yes, a dependently typed language on the JVM!
I have been working on a <a href="https://github.com/mmhelloworld/idris-jvm">JVM bytecode backend for Idris</a> for the past few months and
it is now at a point that we can even write Android programs with Idris without having to write a single line of Java.
In this post, we will see how Idris works on the JVM and an example Android program written in Idris.</p>

<h2>Hello World</h2>

<p>```haskell hellworld.idr
module Main</p>

<p>main : IO ()
main = printLn &ldquo;Hello World&rdquo;
```</p>

<h6>Compile:</h6>

<p><code>bash
$ idris --portable-codegen jvm -p idrisjvmffi helloworld.idr -o target
</code></p>

<p>Dependencies are provided as Idris packages, not as Java dependencies like jar or class files.
The overall process is that the compiler reads Idris files and converts them into an intermediate JSON representation and
the JVM bytecode generator takes the JSON files and converts them into JVM bytecode class files directly.
It is only when we run a Java class, we have to provide Java dependency jars. The output option <code>-o</code> represents a directory
where the Java class files will be created.</p>

<h6>Run:</h6>

<p>```bash
$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main
&ldquo;Hello World&rdquo;</p>

<p>```</p>

<p>And the output folder contains,</p>

<p>```bash
$ tree target
target
├── Decidable
│   └── Equality.class
├── main
│   └── Main.class
└── Prelude</p>

<pre><code>├── Basics.class
├── Bool.class
├── Chars.class
├── Interfaces.class
├── Show.class
└── Strings.class
</code></pre>

<p>```</p>

<p>Why do we have all these classes? We only compiled <code>Main</code> module! This is because Idris performs whole program analysis/compilation
and code generator generates bytecode for all the modules that are relevant for the result produced by the main program.</p>

<h2>How does Idris JVM handle tail calls?</h2>

<p>Idris JVM eliminates self-recursion with JVM <code>GOTO</code> and uses trampolines for other tail calls.
Let&rsquo;s look at the following examples.</p>

<h5>self-recursion example</h5>

<p>```haskell selfrecursion.idr
module Main</p>

<p>import IdrisJvm.IO</p>

<p>sum : Nat &ndash;> Nat
sum n = go 0 n where
  go : Nat &ndash;> Nat &ndash;> Nat
  go acc Z = acc
  go acc n@(S k) = go (acc + n) k</p>

<p>main : JVM_IO ()
main = printLn (sum 50000)</p>

<p>```</p>

<p>This program would work just fine without blowing up the stack as it will be compiled down to a loop that uses JVM&rsquo;s <code>GOTO</code> instruction.
Here is the relevant section from bytecode:</p>

<p>```bash
$ javap -c -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main</p>

<p>  public static java.lang.Object sum$whr$go$colon$0(java.lang.Object, java.lang.Object, java.lang.Object);</p>

<pre><code>Code:
   0: aconst_null
   1: astore        7
   3: aconst_null
   4: astore_3
   5: aconst_null
   6: astore        4
   8: aconst_null
   9: astore        5
  11: aconst_null
  12: astore        6
  14: iconst_1
  15: istore        8
  17: iload         8
  19: ifeq          130
  22: aload_2
  23: new           #80                 // class java/math/BigInteger
  26: dup
  27: ldc           #82                 // String 0
  29: invokespecial #85                 // Method java/math/BigInteger."&lt;init&gt;":(Ljava/lang/String;)V
  32: invokestatic  #333                // Method mmhelloworld/idrisjvmruntime/Util.equals:(Ljava/lang/Object;Ljava/lang/Object;)Z
  35: ifeq          47
  38: aload_1
  39: astore        7
  41: iconst_0
  42: istore        8
  44: goto          127
  47: new           #80                 // class java/math/BigInteger
  50: dup
  51: ldc_w         #335                // String 1
  54: invokespecial #85                 // Method java/math/BigInteger."&lt;init&gt;":(Ljava/lang/String;)V
  57: astore_3
  58: aload_2
  59: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
  62: aload_3
  63: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
  66: invokevirtual #338                // Method java/math/BigInteger.subtract:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
  69: astore_3
  70: new           #80                 // class java/math/BigInteger
  73: dup
  74: ldc_w         #335                // String 1
  77: invokespecial #85                 // Method java/math/BigInteger."&lt;init&gt;":(Ljava/lang/String;)V
  80: astore        4
  82: aload_3
  83: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
  86: aload         4
  88: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
  91: invokevirtual #107                // Method java/math/BigInteger.add:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
  94: astore        4
  96: iconst_0
  97: invokestatic  #41                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
 100: astore        5
 102: aload_1
 103: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
 106: aload         4
 108: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
 111: invokevirtual #107                // Method java/math/BigInteger.add:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
 114: astore        6
 116: aload         5
 118: astore_0
 119: aload         6
 121: astore_1
 122: aload_3
 123: astore_2
 124: goto          127
 127: goto          17
 130: aload         7
 132: areturn
</code></pre>

<p><code>``
The third line from the last is the</code>GOTO` instruction that transfers the control back to the top of function instead of
actually calling the function.</p>

<h5>Mutual recursion example:</h5>

<p>```haskell mutualrecursion.idr
module Main</p>

<p>mutual
  evenT : Nat &ndash;> IO Bool
  evenT Z = pure True
  evenT (S k) = oddT k</p>

<p>  oddT : Nat &ndash;> IO Bool
  oddT Z = pure False
  oddT (S k) = evenT k</p>

<p>main : IO ()
main = printLn !(evenT 9999)</p>

<p>```</p>

<p>The above code also would work fine without killing the stack. Mutual recursion is handled using trampolines and
the tail calls are delayed and compiled down to Java 8 lambdas. As the bytecode for this is bit long, here is the
decompiled bytecode for the <code>evenT</code> function:</p>

<p>```java Decompiled bytecode for evenT</p>

<pre><code>public static Object evenT(Object var0) {
    Object var4 = null;
    Integer var1 = null;
    Integer var2 = null;
    IdrisObject var3 = null;
    if (Util.equals(var0, BigInteger.ZERO)) {
        var1 = Integer.valueOf(0);
        var2 = Integer.valueOf(0);
        var3 = new IdrisObject(1);
        var4 = new IdrisObject(65653, new Object[]{var1, var2, var3});
    } else {
        BigInteger var5 = BigInteger.ONE;
        var5 = Util.asBigInt(var0).subtract(Util.asBigInt(var5));
        var4 = () -&gt; {
            return oddT(var5);
        };
    }

    return var4;
}
</code></pre>

<p>```</p>

<p>As we can see from the decompiled output above, the <code>oddT</code> call is not performed on the same call stack but a thunk
wrapping the function call is returned using lambda (which is compiled down to JVM&rsquo;s <code>invokedynamic</code> instruction).</p>

<p>Here is the relevant bit from bytecode for those who are interested:</p>

<p>```java bytecode for evenT</p>

<pre><code>    68: getstatic     #64                 // Field java/math/BigInteger.ONE:Ljava/math/BigInteger;
    71: astore_1
    72: aload_0
    73: invokestatic  #68                 // Method io/github/mmhelloworld/idrisjvm/runtime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
    76: aload_1
    77: invokestatic  #68                 // Method io/github/mmhelloworld/idrisjvm/runtime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
    80: invokevirtual #72                 // Method java/math/BigInteger.subtract:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
    83: astore_1
    84: aload_1
    85: invokedynamic #79,  0             // InvokeDynamic #1:call:(Ljava/lang/Object;)Lio/github/mmhelloworld/idrisjvm/runtime/Thunk;
    90: astore        4
    92: goto          95
    95: aload         4
    97: areturn
</code></pre>

<p>```</p>

<h2>Java interoperability: Calling Java from Idris and calling Idris from Java</h2>

<p>Idris JVM supports calling Java static methods, instance methods, constructors and also accessing static and instance fields from Idris.
At the moment, except for Java arrays, all the Java types can be constructed from Idris and passed to Java methods.
Support for handling nulls and exceptions is currently in progress and will soon be available.
(Update 01/10/2017: We can now
<a href="http://mmhelloworld.github.io/blog/2017/01/10/idris-jvm-guarding-against-java-null-using-maybe-type/">use <code>Maybe</code> type to avoid Java nulls</a>
in Idris code)</p>

<p>To use Idris functions from Java, Idris JVM supports exporting Idris functions as static methods, instance methods,
constructors of an exported Java class. The exported class can also extend a Java class or implement interfaces with Idris functions.</p>

<p>To demonstrate these features, let&rsquo;s create an Android application In Idris.</p>

<h3>An Android application in Idris</h3>

<p>```haskell idrisandroid.idr
module Main</p>

<p>import IdrisJvm.IO
import Java.Lang</p>

<p>pythag : Int &ndash;> List (Int, Int, Int)
pythag max = [(x, y, z) | z &lt;&ndash; [1..max], y &lt;&ndash; [1..z], x &lt;&ndash; [1..y],</p>

<pre><code>                      x * x + y * y == z * z]
</code></pre>

<p>IdrisAndroidActivity : Type
IdrisAndroidActivity = JVM_Native $ Class &ldquo;hello/IdrisAndroidActivity&rdquo;</p>

<p>Bundle : Type
Bundle = JVM_Native $ Class &ldquo;android/os/Bundle&rdquo;</p>

<p>Context : Type
Context = JVM_Native $ Class &ldquo;android/content/Context&rdquo;</p>

<p>View : Type
View = JVM_Native $ Class &ldquo;android/view/View&rdquo;</p>

<p>TextView : Type
TextView = JVM_Native $ Class &ldquo;android/widget/TextView&rdquo;</p>

<p>Inherits View TextView where {}</p>

<p>CharSequence : Type
CharSequence = JVM_Native $ Class &ldquo;java/lang/CharSequence&rdquo;</p>

<p>Inherits CharSequence String where {}</p>

<p>superOnCreate : IdrisAndroidActivity &ndash;> Bundle &ndash;> JVM_IO ()
superOnCreate = invokeInstance &ldquo;superOnCreate&rdquo; (IdrisAndroidActivity &ndash;> Bundle &ndash;> JVM_IO ())</p>

<p>getApplicationContext : IdrisAndroidActivity &ndash;> JVM_IO Context
getApplicationContext = invokeInstance &ldquo;getApplicationContext&rdquo; (IdrisAndroidActivity &ndash;> JVM_IO Context)</p>

<p>newTextView : Context &ndash;> JVM_IO TextView
newTextView = FFI.new (Context &ndash;> JVM_IO TextView)</p>

<p>setText : Inherits CharSequence charSequence => TextView &ndash;> charSequence &ndash;> JVM_IO ()
setText this text = invokeInstance &ldquo;setText&rdquo; (TextView &ndash;> CharSequence &ndash;> JVM_IO ()) this (believe_me text)</p>

<p>setContentView : Inherits View view => IdrisAndroidActivity &ndash;> view &ndash;> JVM_IO ()
setContentView this view = invokeInstance &ldquo;setContentView&rdquo; (IdrisAndroidActivity &ndash;> View &ndash;> JVM_IO ()) this (believe_me view)</p>

<p>onCreate : IdrisAndroidActivity &ndash;> Bundle &ndash;> JVM_IO ()
onCreate this bundle = do
  superOnCreate this bundle
  context &lt;&ndash; getApplicationContext this
  textView &lt;&ndash; newTextView context
  setText textView $ &ldquo;Hello Android from Idris! pythag 50 is &rdquo; ++ show (pythag 50)
  setContentView this textView</p>

<p>main : IO ()
main = pure ()</p>

<p>androidExport: FFI_Export FFI_JVM &ldquo;hello/IdrisAndroidActivity extends android/support/v7/app/AppCompatActivity&rdquo; []
androidExport =
  Fun superOnCreate (Super &ldquo;onCreate&rdquo;) $
  Fun onCreate (ExportInstance &ldquo;onCreate&rdquo;) $
  End</p>

<p>```</p>

<p>The above program demonstrates calling Java instance methods (<code>setText</code> for example) and constructors (<code>newTextView</code>).</p>

<p>It further demonstrates how to handle inheritance relationship when passing subclass instances to a parent class type.
For example, function <code>setContentView</code> takes a <code>View</code> but we can pass a <code>TextView</code> as it is a subclass of <code>View</code> and we
mention that to Idris via <code>Inherits View TextView where {}</code>.</p>

<p>It also demonstrates how we can create a Java class that extends another class and override methods with Idris functions.
The last section <code>androidExport</code> creates a Java class named <code>hello/IdrisAndroidActivity</code> that extends <code>android/support/v7/app/AppCompatActivity</code>.
The Java class also creates a wrapper method <code>superOnCreate</code> that just delegates to <code>super.OnCreate</code> and the class also overrides <code>onCreate</code> method
with Idris' <code>onCreate</code> function. The Java class can also implement one or more Java interfaces with something like,</p>

<p><code>bash
hello/IdrisAndroidActivity extends android/support/v7/app/AppCompatActivity implements java/lang/Runnable, java/lang/Comparable
</code></p>

<p>A module can have multiple exports so we can actually create multiple Java classes with Idris implementation functions from an Idris module.</p>

<p>We can compile this as usual,</p>

<p><code>idris --portable-codegen jvm -p idrisjvmffi idrisandroid.idr -o target</code></p>

<p>It would produce the following class files:</p>

<p>```
$ tree target/
target/
├── Decidable
│   └── Equality.class
├── hello
│   └── IdrisAndroidActivity.class
├── main
│   ├── Main.class
│   └── Prelude.class
└── Prelude</p>

<pre><code>├── Algebra.class
├── Applicative.class
├── Bool.class
├── Foldable.class
├── Interfaces.class
├── List.class
├── Monad.class
├── Show.class
└── Strings.class
</code></pre>

<p>```</p>

<h5>Deploying to Android:</h5>

<ol>
<li>Create an android project using Android studio with <a href="https://developer.android.com/guide/platform/j8-jack.html#configuration">Jack support for Java 8</a>.</li>
<li>Then package the classes compiled above along with idris-jvm-runtime-1.0-SNAPSHOT.jar classes in a single jar and copy into an
android project&rsquo;s <code>app/libs</code> directory.</li>
<li>Change the activity class name in android manifest file to the Idris exported class name <code>hello.IdrisAndroidActivity</code>.</li>
<li>Then run <code>./gradlew installDebug</code> from android project after starting an emulator or connected to an android device.</li>
<li>Finally we should see our Idris code running on Android! It should look something like this:
<img class="center" src="/images/idris-android.png"></li>
</ol>


<p>Happy coding!</p>
]]></content>
  </entry>
  
</feed>
