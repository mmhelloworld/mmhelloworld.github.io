<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Idris | mmhelloworld]]></title>
  <link href="http://mmhelloworld.github.io/blog/categories/idris/atom.xml" rel="self"/>
  <link href="http://mmhelloworld.github.io/"/>
  <updated>2020-12-30T21:13:52-05:00</updated>
  <id>http://mmhelloworld.github.io/</id>
  <author>
    <name><![CDATA[Marimuthu Madasamy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Idris 2 Bootstrap Compiler on the JVM With a JVM Backend]]></title>
    <link href="http://mmhelloworld.github.io/blog/2020/12/30/idris-2-bootstrap-compiler-on-the-jvm-with-a-jvm-backend/"/>
    <updated>2020-12-30T13:34:21-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2020/12/30/idris-2-bootstrap-compiler-on-the-jvm-with-a-jvm-backend</id>
    <content type="html"><![CDATA[<p>I am excited to announce that Idris 2 bootstrap compiler can now run on the JVM along with a JVM backend. Here is a REPL session:</p>

<pre><code class="haskell">$ idris2
     ____    __     _         ___                                           
    /  _/___/ /____(_)____   |__ \                                          
    / // __  / ___/ / ___/   __/ /     Version 0.1.1-786152de1
  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org           
 /___/\__,_/_/  /_/____/   /____/      Type :? for help                     

[BOOTSTRAP VERSION: No longer developed, except as a bootstrapping step.]
Welcome to Idris 2 on the JVM (Private Build OpenJDK 64-Bit Server VM, 1.8.0_275).  Enjoy yourself!
Main&gt; "hello world"
"hello world"
Main&gt; take 10 [25..]
[25, 26, 27, 28, 29, 30, 31, 32, 33, 34]
Main&gt; :t map
Prelude.map : Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
Main&gt; :exec printLn "Hello Idris 2 on the JVM - this is printed from executing JVM bytecode from memory"
"Hello Idris 2 on the JVM - this is printed from executing JVM bytecode from memory"
Main&gt; 
</code></pre>

<p>You may notice that the banner includes the JVM version the Idris compiler is running on. Idris 2 for JVM can run on Java 8 or above. Since the compiler itself runs on the JVM, the last <code>:exec</code> command above can directly interpret the generated bytecode on the compiler JVM, and the generated bytecode is loaded from memory without any file system footprint.</p>

<h3>To try it out</h3>

<p>Prerequisite: Java 8 or above</p>

<ul>
<li>Extract the zip from <a href="https://github.com/mmhelloworld/Idris2-boot/releases/tag/v0.2.0">here</a></li>
<li>Add <code>idris2-boot-jvm/bin</code> from extracted directory to <code>PATH</code></li>
<li>Run <code>idris2</code>. That&rsquo;s all!</li>
</ul>


<h3>Features</h3>

<ul>
<li>Eliminate tail recursion using JVM&rsquo;s GOTO</li>
<li>Trampoline non-self tail calls</li>
<li>Support file, directory, array, IORef and buffer primitives.</li>
<li>Analyse function dependencies to generate bytecode for only used functions from <code>main</code></li>
<li>Limited type inference on Idris IR to avoid boxing and typecasting in the generated bytecode</li>
<li>Static and instance Java FFI method calls.</li>
<li>Debug information (Idris source file and line numbers) in the bytecode from Idris IR</li>
</ul>


<p>Currently the goal for this bootstrap compiler is to be able to compile current <a href="https://github.com/idris-lang/Idris2">Idris 2</a> so the items here could definitely be improved a lot and other features may be added to support the absolute minimum for building Idris 2.</p>

<h3>Example</h3>

<pre><code class="haskell">module Main

import System.FFI

-- Tail call is eliminated with GOTO
sum : Int -&gt; Int
sum n = go 0 n where
  go : Int -&gt; Int -&gt; Int
  go acc 0 = acc
  go acc n = go (acc + n) (n - 1)

mutual
  -- Mutually recursive functions are trampolined
  -- keeping it simple with int instead of Nat which is compiled to Java BigInteger
  isOdd : Int -&gt; Bool
  isOdd 0 = False
  isOdd n = isEven (n - 1)

  isEven : Int -&gt; Bool
  isEven 0 = True
  isEven n = isOdd (n - 1)

-- Java instance method calls
%foreign jvm "java/lang/String" ".length"
jvmStringLength : String -&gt; Int

-- Java static method calls
%foreign jvm "java/lang/Integer" "toBinaryString"
intToBinaryString : Int -&gt; String

main : IO ()
main = do
  printLn $ sum 5000
  printLn $ isEven 100000
  printLn $ intToBinaryString 512
  printLn $ jvmStringLength "hello"
</code></pre>

<h4>Compile</h4>

<pre><code>idris2 Main.idr -o main
</code></pre>

<p>The classes will be compiled into <code>build/exec/main_app</code>.
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>$ tree build/exec/main_app/
</span><span class='line'>build/exec/main_app/
</span><span class='line'>├── Main.class
</span><span class='line'>├── Prelude
</span><span class='line'>│   ├── $col$col.class
</span><span class='line'>│   ├── Just.class
</span><span class='line'>│   ├── Nil.class
</span><span class='line'>│   ├── Nothing.class
</span><span class='line'>│   ├── Open.class
</span><span class='line'>│   ├── PrefixMinus.class
</span><span class='line'>│   └── Show$spcat$spcPrelude$dotidr$col1260$col1&amp;ndash;1284$col1__mkShow.class
</span><span class='line'>├── Prelude.class
</span><span class='line'>└── PrimIO.class&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;It compiles down to three main modules `Main`, `Prelude` and `PrimIO`. Rest of the classes are data classes for Idris constructors like `Just`, `Nothing`, `Nil`, `::` etc.
</span><span class='line'>
</span><span class='line'>#### Run
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ java -cp /path/to/idris2-boot-jvm/lib/runtime-1.0-SNAPSHOT.jar:build/exec/main_app Main
</span><span class='line'>12502500
</span><span class='line'>True
</span><span class='line'>&amp;ldquo;1000000000&amp;rdquo;
</span><span class='line'>5
</span></code></pre></td></tr></table></div></figure>
The above example demonstrates tail recursion, mutual recursion, Java FFI instance and static method calls.</p>

<p><code>sum</code> a tail recursive function, would be compiled into a loop.  Here is the decompiled code for the nested <code>go</code> function inside <code>sum</code>:</p>

<pre><code class="java">    public static Object $nested1201$307$go(Object arg$0, int arg$1, int arg$2) {
        while(true) {
            switch(arg$2) {
            case 0:
                return arg$1;
            default:
                arg$1 = Prelude.++_Num__Int(arg$1, arg$2);
                arg$2 = Prelude.--_Neg__Int(arg$2, 1);
            }
        }
    }
</code></pre>

<p>As we can see here, the tail recursive function call is removed in the <code>default</code> block instead the arguments are updated for next iteration. The loop would continue to run until the base case is reached where the result is returned.</p>

<p>For <code>isEven</code> and <code>isOdd</code>, the tail calls would be trampolined using JVM&rsquo;s <code>invokedynamic</code>. Here is the decompiled bytecode.</p>

<pre><code class="java">    public static Object isOdd(int arg$0) {
        switch(arg$0) {
        case 0:
            return 1;
        default:
            return () -&gt; {
                return Runtime.createThunk(isEven(Prelude.--_Neg__Int(arg$0, 1)));
            };
        }
    }

    public static Object isEven(int arg$0) {
        switch(arg$0) {
        case 0:
            return 0;
        default:
            return () -&gt; {
                return Runtime.createThunk(isOdd(Prelude.--_Neg__Int(arg$0, 1)));
            };
        }
    }
</code></pre>

<p>Here since the tail call is not to itself, function call is turned into a thunk which would be eventually unwrapped in a loop.</p>

<p>Now let&rsquo;s look at FFI calls in the above example. <code>jvmStringLength</code> function is an example for Java FFI instance method call. It calls <code>length</code> function on Java&rsquo;s <code>java.lang.String</code> instance. Similarly <code>intToBinaryString</code> calls <code>toBinaryString</code> static function on class <code>java.lang.Integer</code>. Function name starting with a dot denotes an instance method call differentiating it from a static method call. Precise types can also be passed explicitly as in the example below with argument types and return type (full code <a href="https://github.com/mmhelloworld/Idris2-boot/blob/master/libs/base/System/File.idr#L37">here</a>).</p>

<pre><code class="haskell">%foreign jvm' fileClass "getLine" fileClass "String"
prim__readLine : FilePtr -&gt; PrimIO (Ptr String)
</code></pre>

<h3>Next steps</h3>

<p>Next step would be to use this bootstrap version to compile current <a href="https://github.com/idris-lang/Idris2">Idris 2</a> and then porting the JVM backend from here which is on Idris 1 to Idris 2 so there are some interesting things ahead to work on. Meanwhile, if anyone gets a chance to use this boostrap JVM version, please share any feedback or any issues <a href="https://github.com/mmhelloworld/idris-jvm/discussions">here</a> that can help while we try to compile mainstream Idris 2 for the JVM. Thank you for reading and happy coding!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Idris JVM: Automated FFI With Null Safety and Exception Handling]]></title>
    <link href="http://mmhelloworld.github.io/blog/2018/02/11/idris-jvm-automated-ffi-with-null-safety/"/>
    <updated>2018-02-11T00:03:00-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2018/02/11/idris-jvm-automated-ffi-with-null-safety</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>Idris JVM backend has supported foreign function calls for some time now. For example, to invoke <code>parseInt</code> method on
<code>java.lang.Integer</code> class,</p>

<pre><code class="haskell">invokeStatic (Class "java/lang/Integer") "parseInt" (String -&gt; JVM_IO Int) "234" 
</code></pre>

<p>Here since the Idris compiler doesn&rsquo;t know anything about Java&rsquo;s <code>Integer</code> class or its <code>parseInt</code> method, we have to
explicitly provide the function signature. The function call also has the explicit <code>Class</code>
before <code>java/lang/Integer</code> and the type of invocation <code>invokeStatic</code>.</p>

<p>Since we are targeting JVM bytecode, JVM has to know whether a method call is a static method call or an interface
method call or a virtual method call. It would be nice if we don&rsquo;t have to worry about any of these things and
just call a FFI function with a class name, method name and the arguments. This is the motivation behind this
new feature along with some other nice things like null safety, construtor and method overloading resolution
and exception handling.</p>

<h4>Maybe and Either in foreign function calls</h4>

<p><code>Maybe</code> type and <code>Either</code> type can be used in foreign function calls for null safety and exception handling. <code>Maybe</code>
type can be used for argument types and return types. <code>Maybe</code> type used in an argument position will pass <code>null</code>
to the target foreign function if it is <code>Nothing</code> or the actual value if it is <code>Just</code>. Similarly, <code>Maybe</code> type
used for return type will convert <code>null</code> returned from foreign function into <code>Nothing</code> and the non-null value into
<code>Just.</code> At the bytecode level, <code>Maybe</code> wrapper doesn&rsquo;t exist. It gets compiled down to
<code>null</code> or the actual value.</p>

<p><code>Either</code> type can only be used in return types to indicate whether the foreign function can throw exceptions.
At runtime, if the foreign function throws exception, it will be captured in the &ldquo;left&rdquo; of type <code>Throwable</code> or if the
foreign function completes normally, the result will be stored in the &ldquo;right&rdquo; of result type. There are functions <code>try</code>
and <code>catch</code> to handle exceptions which we will see later in the post.</p>

<h2>How it works</h2>

<p>Before we look at some examples, first let&rsquo;s declare some class names as we are going to use them in multiple places and
we don&rsquo;t want to duplicate.</p>

<pre><code class="haskell">stringClass: String
stringClass = "java/lang/String"

listInterface: String
listInterface = "java/util/List"

arrayListClass: String
arrayListClass = "java/util/ArrayList"

collectionInterface : String
collectionInterface = "java/util/Collection"

systemClass: String
systemClass = "java/lang/System"

comparatorClass : String
comparatorClass = "java/util/Comparator"

pointClass : String
pointClass = "java/awt/Point"

collectionsClass : String
collectionsClass = "java/util/Collections"

stringBuilderClass : String
stringBuilderClass = "java/lang/StringBuilder"

objectsClass : String
objectsClass = "java/util/Objects"

integerClass : String
integerClass = "java/lang/Integer"
</code></pre>

<p>And &ldquo;import&rdquo; some methods:</p>

<pre><code class="haskell">jdkimport [
    (systemClass, ["getProperty", "setProperty"]),
    (stringClass, ["substring", "CASE_INSENSITIVE_ORDER", "valueOf"]),
    (integerClass, ["parseInt"]),
    (comparatorClass, ["compare"]),
    (arrayListClass, ["&lt;init&gt;", "add"]),
    (listInterface, ["get"]),
    (collectionsClass, ["max"]),
    (stringBuilderClass, ["&lt;init&gt;", "toString"]),
    (objectsClass, ["toString"]),
    (pointClass, ["&lt;init&gt;", "x"])
  ]
</code></pre>

<p>Here <code>jdkimport</code> is just an additional syntax created using Idris syntax extensions. It just calls a type provider
function written in Idris to know about these classes, methods and fields. Note that it imports fields such as
<code>CASE_INSENSITIVE_ORDER</code>, <code>x</code> and also constructors in the name of <code>&lt;init&gt;</code> which is the JVM internal name for
constructors. The <code>jdkimport</code> syntax launches a JVM during compilation without any classpath so it basically can import
all the JDK classes and methods.</p>

<p>There is also another syntax called <code>jvmimport</code> that can take an additional argument, a command, which could be just the
JVM with correct classpath or could be a build tool that properly sets up the classpath from your project dependencies so
that we can &ldquo;import&rdquo; classes and methods from external foreign libraries.</p>

<p>Once the information about JVM classes and methods is collected using type provider, appropriate call site, Idris code
similar to the one in the beginning of the post can be created using Idris elaborator reflection with just class name
and member name from the user. As a user, we don&rsquo;t have to know much about these internals, we just need to import classes
and members and can use them without having to explicitly provide foreign types. Now let&rsquo;s look at some examples on how we can
actually make FFI calls in the new way.</p>

<h2>Examples</h2>

<h4>1. Safe static method call</h4>

<pre><code class="haskell">main : JVM_IO ()
main = do
  exceptionOrInt &lt;- (integerClass &lt;.&gt; "parseInt") "1234"
  printLn $ either (const 0) id exceptionOrInt 
</code></pre>

<p>Here the type of <code>(integerClass &lt;.&gt; "parseInt")</code> is <code>String -&gt; JVM_IO (Either Throwable Int)</code>. Since the method can throw
exceptions, it returns an <code>Either</code>. Here we return <code>0</code> in case of an exception. Later in the post, we will see a
detailed example of exception handling. As the method returns an <code>Int</code> which is a primitive type in JVM, it cannot be
null and the FFI call already knows that hence the result <code>Int</code> is not wrapped in a <code>Maybe</code>. We don&rsquo;t provide any
explicit type signature for the foreign function. If we try to pass anything other than <code>String</code> for this foreign
function, it will be a compilation error!</p>

<h4>2. Unsafe static method call</h4>

<pre><code class="haskell">  do
    number &lt;- (integerClass &lt;.!&gt; "parseInt") "23"
    printLn number
</code></pre>

<p>Here we use <code>&lt;.!&gt;</code> with an <code>!</code> to indicate an unsafe method call instead of <code>&lt;.&gt;</code>. There is also <code>javaUnsafe</code> and <code>java</code>
if you prefer names to operators. The type of <code>(integerClass &lt;.!&gt; "parseInt")</code> is <code>String -&gt; JVM_IO Int</code>.
Sometimes if we are sure that the foreign function would not return null or throw exceptions, we can use unsafe method
calls but as the name indicates, it would fail at runtime if null is returned or an exception is thrown.</p>

<h4>3. Overloading resolution</h4>

<p>We can pick which overloaded variant we want to use by passing appropriate types to the foreign function and
the FFI call will automatically have corresponding types.</p>

<pre><code class="haskell">printLn !((stringClass &lt;.!&gt; "valueOf(double)") 2.5)
printLn !((stringClass &lt;.!&gt; "valueOf(char)") 'H')
</code></pre>

<p>The first function takes an Idris <code>Double</code> and the second function takes Idris <code>Char</code>. The types passed to the foreign
functions to resolve overloading are JVM types.</p>

<h4>4. Safe instance method</h4>

<pre><code class="haskell">  do
    s &lt;- (stringClass &lt;.&gt; "substring(int)") "Foobar" 1
    putStrLn !(either throw (pure . show) s) 
</code></pre>

<p>Safe instance method calls are similar to static method calls except that the instance should be passed as the first
argument. Here again, we don&rsquo;t provide any explicit type signature or the type of method invocation whether it is static or
instance method but it all works out automatically in a type safe way. Here also we pick a particular overloaded version.</p>

<p>The type of <code>(stringClass &lt;.&gt; "substring(int)")</code> is <code>String -&gt; Int -&gt; JVM_IO (Either Throwable (Maybe String))</code>.
Since the return type is <code>String</code> and it can be null, it is in a <code>Maybe</code> and the method can throw exceptions so the
overall type is in <code>Either</code>.</p>

<h4>5. Exception handling</h4>

<pre><code class="haskell">do
  propValue &lt;- try ((systemClass &lt;.&gt; "getProperty(?java/lang/String)") Nothing) [
    ([catch IllegalArgumentExceptionClass, catch NullPointerExceptionClass], \t =&gt;
      do
        printLn "property name is null or empty"
        pure Nothing
    ),
    ([catchNonFatal], \t =&gt;
      do
        printLn "unable to get property value"
        pure Nothing
    )
  ]
  printLn propValue
</code></pre>

<p>This example shows how to handle exceptions with different handlers and also shows how to pass a <code>null</code> to a foreign function.
If a FFI function argument type is prefixed with <code>?</code>, then the idris type would be <code>Maybe nativeTy</code> and we can pass
<code>Nothing</code> to pass a <code>null</code> to the foreign function. We can have handlers for single exception, multiple exceptions or
for all non fatal errors similar to Scala&rsquo;s
<a href="https://github.com/scala/scala/blob/2.12.x/src/library/scala/util/control/NonFatal.scala">NonFatal</a>.</p>

<h4>6. Constructors</h4>

<pre><code class="haskell">do
  arrayList1 &lt;- (arrayListClass &lt;.&gt; "&lt;init&gt;(int)") 10
  putStrLn !(either throw toString arrayList1)

  -- Unsafe constructor
  arrayList2 &lt;- arrayListClass &lt;.!&gt; "&lt;init&gt;()"
  putStrLn !(toString arrayList2)
</code></pre>

<p>Similar to methods, constructors can be overloaded and we can select a particular overload variant by explicitly
specifying the foreign type. Constructors can also be invoked in a safe or unsafe way. As constructors cannot return
null, when invoked in a safe way, the result type will only be in <code>Either</code> and not wrapped in a <code>Maybe</code>.</p>

<h4>7. Fields</h4>

<pre><code class="haskell">do
  -- static field getter
  caseInsensitiveComparator &lt;- stringClass &lt;.#!&gt; "CASE_INSENSITIVE_ORDER"
  printLn !((comparatorClass &lt;.!&gt; "compare") caseInsensitiveComparator "Bar" "august")

  point &lt;- (pointClass &lt;.!&gt; "&lt;init&gt;(int,int)") 2 3

  -- instance field getter
  printLn !((pointClass &lt;.#&gt; "x") point)

  -- instance field setter
  (pointClass &lt;.=&gt; "x") point 34
  printLn !((pointClass &lt;.#&gt; "x") point)
</code></pre>

<p>Similar to methods and constructors, fields can also be accessed either in a safe or unsafe way using <code>&lt;.#&gt;</code> for safe
getter, <code>&lt;.=&gt;</code> for safe setter, <code>&lt;.#!&gt;</code> for unsafe getter and <code>&lt;.=!&gt;</code> for unsafe setter. Since field access
cannot throw a exception, the return type is automatically just <code>Maybe nativeTy</code>. The field types are automatically
determined without the user having to provide the foreign types of the fields.</p>

<h2>Summary</h2>

<p>This post demonstrated how with Idris' powerful features FFI, type provider and elaborator reflection, we can safely and
easily access JVM foreign functions. We can access fields, methods and constructors without having to explicitly provide
foreign types and we can access them in safe way without <code>null</code> getting into Idris code and handle exceptions thrown by
foreign functions. It also showed how to call overloaded methods and constructors and how <code>Maybe</code> and <code>Either</code> types are
used with foreign functions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Idris JVM: Guarding Against Java Null Using Maybe Type]]></title>
    <link href="http://mmhelloworld.github.io/blog/2017/01/10/idris-jvm-guarding-against-java-null-using-maybe-type/"/>
    <updated>2017-01-10T21:08:00-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2017/01/10/idris-jvm-guarding-against-java-null-using-maybe-type</id>
    <content type="html"><![CDATA[<p>Idris JVM now helps avoiding nulls getting into Idris from FFI calls using <code>Maybe</code> type.
FFI declarations can have <code>Maybe</code> type in any argument position or in the return type.</p>

<h2>Handling <code>null</code> from FFI call</h2>

<pre><code class="haskell">getProperty : String -&gt; JVM_IO (Maybe String)
getProperty = invokeStatic SystemClass "getProperty" (String -&gt; JVM_IO (Maybe String))
</code></pre>

<p>The above function is an FFI call to Java&rsquo;s method
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperty-java.lang.String-"><code>static String getProperty(String key)</code></a>.
The method returns a system property value if the property is set otherwise returns null.
With <code>Maybe</code> type in the Idris function&rsquo;s return type, the Idris function returns <code>Nothing</code> if the returned value is null
otherwise the value is wrapped in <code>Just</code>.</p>

<h6>Example</h6>

<pre><code class="haskell returningnull.idr">module Main

import IdrisJvm.IO
import Java.Lang

main : JVM_IO ()
main = printLn !(getProperty "foo")  
</code></pre>

<pre><code class="bash">$ idris --portable-codegen jvm -p idrisjvmffi returningnull.idr -o target

$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main
Nothing

$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar -Dfoo=hello main.Main
Just "hello"
</code></pre>

<h2>Passing <code>Maybe</code> values for nullable values in FFI calls</h2>

<pre><code class="haskell passingnull.idr">module Main

import IdrisJvm.IO
import Java.Lang

namespace Component
  Component : Type
  Component = JVM_Native $ Class "java/awt/Component"

namespace JOptionPane
  JOptionPaneClass : JVM_NativeTy
  JOptionPaneClass = Class "javax/swing/JOptionPane"

  showMessageDialog : Inherits Object messageTy =&gt; Maybe Component -&gt; messageTy -&gt; JVM_IO ()
  showMessageDialog parent message =
    invokeStatic JOptionPaneClass "showMessageDialog" (Maybe Component -&gt; Object -&gt; JVM_IO ()) parent (believe_me message)

main : JVM_IO ()
main = showMessageDialog Nothing "Hello Idris!"
</code></pre>

<p>In the above code, the Java method
<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JOptionPane.html#showMessageDialog-java.awt.Component-java.lang.Object-"><code>JOptionPane.showMessageDialog(parentComponent, message)</code></a>
takes a nullable parent component and a message. If the parent component is <code>null</code> then the message is displayed in a default frame.</p>

<pre><code>$ idris --portable-codegen jvm -p idrisjvmffi passingnull.idr -o target

$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main
</code></pre>

<p>Idris code passes <code>Nothing</code> in the above code so <code>null</code> is passed for the Java method that displays the message in a default frame as shown below.
<img class="center" src="/images/idris-passing-null.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Idris on the JVM and an Idris Android Example]]></title>
    <link href="http://mmhelloworld.github.io/blog/2017/01/06/introducing-idris-on-the-jvm-and-an-idris-android-example/"/>
    <updated>2017-01-06T22:51:00-05:00</updated>
    <id>http://mmhelloworld.github.io/blog/2017/01/06/introducing-idris-on-the-jvm-and-an-idris-android-example</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/mmhelloworld/idris-jvm">Idris on the JVM!</a> Yes, a dependently typed language on the JVM!
I have been working on a <a href="https://github.com/mmhelloworld/idris-jvm">JVM bytecode backend for Idris</a> for the past few months and
it is now at a point that we can even write Android programs with Idris without having to write a single line of Java.
In this post, we will see how Idris works on the JVM and an example Android program written in Idris.</p>

<h2>Hello World</h2>

<pre><code class="haskell hellworld.idr">module Main

main : IO ()
main = printLn "Hello World"
</code></pre>

<h6>Compile:</h6>

<pre><code class="bash">$ idris --portable-codegen jvm -p idrisjvmffi helloworld.idr -o target
</code></pre>

<p>Dependencies are provided as Idris packages, not as Java dependencies like jar or class files.
The overall process is that the compiler reads Idris files and converts them into an intermediate JSON representation and
the JVM bytecode generator takes the JSON files and converts them into JVM bytecode class files directly.
It is only when we run a Java class, we have to provide Java dependency jars. The output option <code>-o</code> represents a directory
where the Java class files will be created.</p>

<h6>Run:</h6>

<pre><code class="bash">$ java -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main
"Hello World"
</code></pre>

<p>And the output folder contains,</p>

<pre><code class="bash">$ tree target
target
├── Decidable
│   └── Equality.class
├── main
│   └── Main.class
└── Prelude
    ├── Basics.class
    ├── Bool.class
    ├── Chars.class
    ├── Interfaces.class
    ├── Show.class
    └── Strings.class
</code></pre>

<p>Why do we have all these classes? We only compiled <code>Main</code> module! This is because Idris performs whole program analysis/compilation
and code generator generates bytecode for all the modules that are relevant for the result produced by the main program.</p>

<h2>How does Idris JVM handle tail calls?</h2>

<p>Idris JVM eliminates self-recursion with JVM <code>GOTO</code> and uses trampolines for other tail calls.
Let&rsquo;s look at the following examples.</p>

<h5>self-recursion example</h5>

<pre><code class="haskell selfrecursion.idr">module Main

import IdrisJvm.IO

sum : Nat -&gt; Nat
sum n = go 0 n where
  go : Nat -&gt; Nat -&gt; Nat
  go acc Z = acc
  go acc n@(S k) = go (acc + n) k

main : JVM_IO ()
main = printLn (sum 50000)
</code></pre>

<p>This program would work just fine without blowing up the stack as it will be compiled down to a loop that uses JVM&rsquo;s <code>GOTO</code> instruction.
Here is the relevant section from bytecode:</p>

<pre><code class="bash">$ javap -c -cp target:/path/to/idris-jvm-runtime-1.0-SNAPSHOT.jar main.Main

  public static java.lang.Object sum$whr$go$colon$0(java.lang.Object, java.lang.Object, java.lang.Object);
    Code:
       0: aconst_null
       1: astore        7
       3: aconst_null
       4: astore_3
       5: aconst_null
       6: astore        4
       8: aconst_null
       9: astore        5
      11: aconst_null
      12: astore        6
      14: iconst_1
      15: istore        8
      17: iload         8
      19: ifeq          130
      22: aload_2
      23: new           #80                 // class java/math/BigInteger
      26: dup
      27: ldc           #82                 // String 0
      29: invokespecial #85                 // Method java/math/BigInteger."&lt;init&gt;":(Ljava/lang/String;)V
      32: invokestatic  #333                // Method mmhelloworld/idrisjvmruntime/Util.equals:(Ljava/lang/Object;Ljava/lang/Object;)Z
      35: ifeq          47
      38: aload_1
      39: astore        7
      41: iconst_0
      42: istore        8
      44: goto          127
      47: new           #80                 // class java/math/BigInteger
      50: dup
      51: ldc_w         #335                // String 1
      54: invokespecial #85                 // Method java/math/BigInteger."&lt;init&gt;":(Ljava/lang/String;)V
      57: astore_3
      58: aload_2
      59: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
      62: aload_3
      63: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
      66: invokevirtual #338                // Method java/math/BigInteger.subtract:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
      69: astore_3
      70: new           #80                 // class java/math/BigInteger
      73: dup
      74: ldc_w         #335                // String 1
      77: invokespecial #85                 // Method java/math/BigInteger."&lt;init&gt;":(Ljava/lang/String;)V
      80: astore        4
      82: aload_3
      83: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
      86: aload         4
      88: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
      91: invokevirtual #107                // Method java/math/BigInteger.add:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
      94: astore        4
      96: iconst_0
      97: invokestatic  #41                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
     100: astore        5
     102: aload_1
     103: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
     106: aload         4
     108: invokestatic  #103                // Method mmhelloworld/idrisjvmruntime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
     111: invokevirtual #107                // Method java/math/BigInteger.add:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
     114: astore        6
     116: aload         5
     118: astore_0
     119: aload         6
     121: astore_1
     122: aload_3
     123: astore_2
     124: goto          127
     127: goto          17
     130: aload         7
     132: areturn
</code></pre>

<p>The third line from the last is the <code>GOTO</code> instruction that transfers the control back to the top of function instead of
actually calling the function.</p>

<h5>Mutual recursion example:</h5>

<pre><code class="haskell mutualrecursion.idr">module Main

mutual
  evenT : Nat -&gt; IO Bool
  evenT Z = pure True
  evenT (S k) = oddT k

  oddT : Nat -&gt; IO Bool
  oddT Z = pure False
  oddT (S k) = evenT k

main : IO ()
main = printLn !(evenT 9999)
</code></pre>

<p>The above code also would work fine without killing the stack. Mutual recursion is handled using trampolines and
the tail calls are delayed and compiled down to Java 8 lambdas. As the bytecode for this is bit long, here is the
decompiled bytecode for the <code>evenT</code> function:</p>

<pre><code class="java Decompiled bytecode for evenT">    public static Object evenT(Object var0) {
        Object var4 = null;
        Integer var1 = null;
        Integer var2 = null;
        IdrisObject var3 = null;
        if (Util.equals(var0, BigInteger.ZERO)) {
            var1 = Integer.valueOf(0);
            var2 = Integer.valueOf(0);
            var3 = new IdrisObject(1);
            var4 = new IdrisObject(65653, new Object[]{var1, var2, var3});
        } else {
            BigInteger var5 = BigInteger.ONE;
            var5 = Util.asBigInt(var0).subtract(Util.asBigInt(var5));
            var4 = () -&gt; {
                return oddT(var5);
            };
        }

        return var4;
    }
</code></pre>

<p>As we can see from the decompiled output above, the <code>oddT</code> call is not performed on the same call stack but a thunk
wrapping the function call is returned using lambda (which is compiled down to JVM&rsquo;s <code>invokedynamic</code> instruction).</p>

<p>Here is the relevant bit from bytecode for those who are interested:</p>

<pre><code class="java bytecode for evenT">        68: getstatic     #64                 // Field java/math/BigInteger.ONE:Ljava/math/BigInteger;
        71: astore_1
        72: aload_0
        73: invokestatic  #68                 // Method io/github/mmhelloworld/idrisjvm/runtime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
        76: aload_1
        77: invokestatic  #68                 // Method io/github/mmhelloworld/idrisjvm/runtime/Util.asBigInt:(Ljava/lang/Object;)Ljava/math/BigInteger;
        80: invokevirtual #72                 // Method java/math/BigInteger.subtract:(Ljava/math/BigInteger;)Ljava/math/BigInteger;
        83: astore_1
        84: aload_1
        85: invokedynamic #79,  0             // InvokeDynamic #1:call:(Ljava/lang/Object;)Lio/github/mmhelloworld/idrisjvm/runtime/Thunk;
        90: astore        4
        92: goto          95
        95: aload         4
        97: areturn
</code></pre>

<h2>Java interoperability: Calling Java from Idris and calling Idris from Java</h2>

<p>Idris JVM supports calling Java static methods, instance methods, constructors and also accessing static and instance fields from Idris.
At the moment, except for Java arrays, all the Java types can be constructed from Idris and passed to Java methods.
Support for handling nulls and exceptions is currently in progress and will soon be available.
(Update 01/10/2017: We can now
<a href="http://mmhelloworld.github.io/blog/2017/01/10/idris-jvm-guarding-against-java-null-using-maybe-type/">use <code>Maybe</code> type to avoid Java nulls</a>
in Idris code)</p>

<p>To use Idris functions from Java, Idris JVM supports exporting Idris functions as static methods, instance methods,
constructors of an exported Java class. The exported class can also extend a Java class or implement interfaces with Idris functions.</p>

<p>To demonstrate these features, let&rsquo;s create an Android application In Idris.</p>

<h3>An Android application in Idris</h3>

<pre><code class="haskell idrisandroid.idr">module Main

import IdrisJvm.IO
import Java.Lang

pythag : Int -&gt; List (Int, Int, Int)
pythag max = [(x, y, z) | z &lt;- [1..max], y &lt;- [1..z], x &lt;- [1..y],
                          x * x + y * y == z * z]

IdrisAndroidActivity : Type
IdrisAndroidActivity = JVM_Native $ Class "hello/IdrisAndroidActivity"

Bundle : Type
Bundle = JVM_Native $ Class "android/os/Bundle"

Context : Type
Context = JVM_Native $ Class "android/content/Context"

View : Type
View = JVM_Native $ Class "android/view/View"

TextView : Type
TextView = JVM_Native $ Class "android/widget/TextView"

Inherits View TextView where {}

CharSequence : Type
CharSequence = JVM_Native $ Class "java/lang/CharSequence"

Inherits CharSequence String where {}

superOnCreate : IdrisAndroidActivity -&gt; Bundle -&gt; JVM_IO ()
superOnCreate = invokeInstance "superOnCreate" (IdrisAndroidActivity -&gt; Bundle -&gt; JVM_IO ())

getApplicationContext : IdrisAndroidActivity -&gt; JVM_IO Context
getApplicationContext = invokeInstance "getApplicationContext" (IdrisAndroidActivity -&gt; JVM_IO Context)

newTextView : Context -&gt; JVM_IO TextView
newTextView = FFI.new (Context -&gt; JVM_IO TextView)

setText : Inherits CharSequence charSequence =&gt; TextView -&gt; charSequence -&gt; JVM_IO ()
setText this text = invokeInstance "setText" (TextView -&gt; CharSequence -&gt; JVM_IO ()) this (believe_me text)

setContentView : Inherits View view =&gt; IdrisAndroidActivity -&gt; view -&gt; JVM_IO ()
setContentView this view = invokeInstance "setContentView" (IdrisAndroidActivity -&gt; View -&gt; JVM_IO ()) this (believe_me view)

onCreate : IdrisAndroidActivity -&gt; Bundle -&gt; JVM_IO ()
onCreate this bundle = do
  superOnCreate this bundle
  context &lt;- getApplicationContext this
  textView &lt;- newTextView context
  setText textView $ "Hello Android from Idris! pythag 50 is " ++ show (pythag 50)
  setContentView this textView

main : IO ()
main = pure ()

androidExport: FFI_Export FFI_JVM "hello/IdrisAndroidActivity extends android/support/v7/app/AppCompatActivity" []
androidExport =
  Fun superOnCreate (Super "onCreate") $
  Fun onCreate (ExportInstance "onCreate") $
  End
</code></pre>

<p>The above program demonstrates calling Java instance methods (<code>setText</code> for example) and constructors (<code>newTextView</code>).</p>

<p>It further demonstrates how to handle inheritance relationship when passing subclass instances to a parent class type.
For example, function <code>setContentView</code> takes a <code>View</code> but we can pass a <code>TextView</code> as it is a subclass of <code>View</code> and we
mention that to Idris via <code>Inherits View TextView where {}</code>.</p>

<p>It also demonstrates how we can create a Java class that extends another class and override methods with Idris functions.
The last section <code>androidExport</code> creates a Java class named <code>hello/IdrisAndroidActivity</code> that extends <code>android/support/v7/app/AppCompatActivity</code>.
The Java class also creates a wrapper method <code>superOnCreate</code> that just delegates to <code>super.OnCreate</code> and the class also overrides <code>onCreate</code> method
with Idris' <code>onCreate</code> function. The Java class can also implement one or more Java interfaces with something like,</p>

<pre><code class="bash">hello/IdrisAndroidActivity extends android/support/v7/app/AppCompatActivity implements java/lang/Runnable, java/lang/Comparable
</code></pre>

<p>A module can have multiple exports so we can actually create multiple Java classes with Idris implementation functions from an Idris module.</p>

<p>We can compile this as usual,</p>

<p><code>idris --portable-codegen jvm -p idrisjvmffi idrisandroid.idr -o target</code></p>

<p>It would produce the following class files:</p>

<pre><code>$ tree target/
target/
├── Decidable
│   └── Equality.class
├── hello
│   └── IdrisAndroidActivity.class
├── main
│   ├── Main.class
│   └── Prelude.class
└── Prelude
    ├── Algebra.class
    ├── Applicative.class
    ├── Bool.class
    ├── Foldable.class
    ├── Interfaces.class
    ├── List.class
    ├── Monad.class
    ├── Show.class
    └── Strings.class
</code></pre>

<h5>Deploying to Android:</h5>

<ol>
<li>Create an android project using Android studio with <a href="https://developer.android.com/guide/platform/j8-jack.html#configuration">Jack support for Java 8</a>.</li>
<li>Then package the classes compiled above along with idris-jvm-runtime-1.0-SNAPSHOT.jar classes in a single jar and copy into an
android project&rsquo;s <code>app/libs</code> directory.</li>
<li>Change the activity class name in android manifest file to the Idris exported class name <code>hello.IdrisAndroidActivity</code>.</li>
<li>Then run <code>./gradlew installDebug</code> from android project after starting an emulator or connected to an android device.</li>
<li>Finally we should see our Idris code running on Android! It should look something like this:
<img class="center" src="/images/idris-android.png"></li>
</ol>


<p>Happy coding!</p>
]]></content>
  </entry>
  
</feed>
